#!/usr/bin/env bash
#
#         _       _
#        | |     | |
#      __| | ___ | |_ ___
#     / _` |/ _ \| __/ __|
#    | (_| | (_) | |_\__ \
#     \__,_|\___/ \__|___/
#
#
# A local configuration framework.
#
# Â© William Melody - hi@williammelody.com
#
# Inspired and some portions adapted from Manuel by Shane Kilkelly:
# https://github.com/ShaneKilkelly/manuel

###############################################################################
# Debug
###############################################################################

# _debug()
#
# Shortcut for testing against the existence of a $debug variable. Primarily
# intended to be used before a printf statement.
#
# Usage:
#   _debug && printf "Debug info"
_debug() { [[ -n "$debug" ]]; }

###############################################################################
# Options
###############################################################################

# Get raw options for any tasks that expect them.
raw_options=$*

# Initialize task options and arguments arrays.
#
# These contain any options and arguments that will be used by the tasks.
# Tasks handle their own argument and option checks using the created arrays.
task_options=()
task_arguments=()

while [ $# -gt 0 ]; do
  opt="$1"
  shift
  case "$opt" in
    -h|--help)
      task="help"
      ;;
    --debug)
      debug=1
      ;;
    -*|--*)
      task_options+=("$opt")
      ;;
    bin|home)
      # If an argument prior to the task name is either 'bin' or 'home', set
      # that as the context. Otherwise, if the task has already been set, then
      # any matches are assumed to be task arguments.
      if [[ -z $task ]]; then
        context="$opt"
      else
        task_arguments+=("$opt")
      fi
      ;;
    *)
      # The first non-context argument encountered is assumed to be the task
      # name, and all subsequent arguments are set as task arguments.
      if [[ -n $task ]]; then
        task_arguments+=("$opt")
      else
        task=$opt
      fi
      ;;
  esac
done

# If no context was set from the options, default to 'home'.
if [[ -z $context ]]; then
  context="home"
fi

_debug && printf "\$context: %s\n" "$context"
_debug && printf "\$task: %s\n" "$task"
_debug && printf "\$raw_options: %s\n" "$raw_options"
_debug && printf "\$task_options: %s\n" "${task_options[*]}"
_debug && printf "\$task_arguments: %s\n" "${task_arguments[*]}"

###############################################################################
# Environment
###############################################################################

# $_me
#
# Set to the command's basename.
_me=$(basename "$0")

_debug && printf "\$_me: %s\n" "$_me"

# Ensure that $DOTFILES is set in the environment.
if [[ -z $DOTFILES ]]; then
  DOTFILES="$HOME/.dotfiles"
fi

# $tracked_dir
#
# Set to either 'home' or 'bin' within the dotfiles repository, depending on
# the context.
if [[ "$context" == "bin" ]]; then
  tracked_dir=$DOTFILES/bin
else
  tracked_dir=$DOTFILES/home
fi

_debug && printf "\$tracked_dir: %s\n" "$tracked_dir"

# $original_dir
#
# Set to either '$HOME/bin' or '$HOME', depending on the context.
if [[ "$context" == "bin" ]]; then
  original_dir=$HOME/bin
else
  original_dir=$HOME
fi

_debug && printf "\$original_dir: %s\n" "$original_dir"

###############################################################################
# Main
###############################################################################

# _main()
#
# Usage:
#   _main
#
# The primary function for starting the program.
#
# NOTE: must be called at end of program after all tasks have been defined.
_main() {
  # If $task is blank, then set to help
  if [[ -z $task ]]; then
    task="help"
  fi

  # Get the list of defined tasks.
  defined_tasks=($(tasks --raw))

  # Run the task and pass the task arguments.
  if ( _contains "$task" "${defined_tasks[@]}" ); then
    $task "${task_arguments[@]}"
  else
    printf "Unknown task: %s\n" "$task"
    exit 1
  fi
}

###############################################################################
# Utility Functions
###############################################################################

# _each_file()
#
# Iterate over the files in the specified directory and execute the specified
# function.
#
# Usage: _each_file directory function
_each_file() {
  per_file_function=$2
  if [[ "$context" == "home" ]]; then
    search_files="$1/.*"
  else
    search_files="$1/*"
  fi
  for f in $search_files
  do
    filename=$(basename "$f")
    tracked_file=$tracked_dir/$filename
    original_file=$original_dir/$filename
    if [[ "$context" == "home" ]]; then
      if ! ( [[ "$filename" =~ ^\.?\.$ ]] ); then
        # Subfunctions can access the variables in this function, so it's not
        # necessary to pass them as arguments.
        $per_file_function
      fi
    else
      $per_file_function
    fi
  done
}

# _runner()
#
# Run or list scripts in a specified script subdirectory.
#
# Usage: _runner subdirectory ( --all | <list> | <script_name> )
_run_script() {
  if [[ -e "$1" ]]; then
    printf ">> Running %s\n" "$(basename "$1")"
    $1
  else
    printf "'%s' not found.\n" "$1" && exit 1
  fi
}
_runner() {
  [[ -z $1 ]] && printf "_runner: No subdirectory specified.\n" && exit 1
  subdir=$1
  subdir_path=$DOTFILES/script/$subdir
  script_file=$subdir_path/$2
  if _contains "--all" "${task_options[@]}"; then
    for f in $subdir_path/*
    do
      _run_script "$f"
    done
  elif [[ -n "$2" ]]; then
    if [[ "$2" == "list" ]]; then
      for f in $subdir_path/*
      do
        basename "$f"
      done
    else
      _run_script "$script_file"
    fi
  else
    cat <<EOM
Script must be specified. You can see available scripts by running the \
following command:

$_me $1 list
EOM
    exit 1
  fi
}

# _each_tracked_file()
#
# Iterate over the files in the tracked directory and execute the specified
# function.
#
# Usage: _each_tracked_file function
_each_tracked_file() {
  _each_file "$tracked_dir" "$1"
}

# _each_original_file()
#
# Iterate over the files in the original directory and execute the specified
# function.
#
# Usage: _each_original_file function
_each_original_file() {
  _each_file "$original_dir" "$1"
}

# _function_exists()
#
# Takes a potential function name as an argument and returns whether a function
# exists with that name.
_function_exists() {
  [ "$(type -t "$1")" == 'function' ]
}

# _contains()
#
# Takes an item and a list and determines whether the list contains the item.
#
# Usage:
#   _contains "$item" "${list[@]}"
_contains() {
  local e
  for e in "${@:2}"; do [[ "$e" == "$1" ]] && return 0; done
  return 1
}

###############################################################################
# desc
###############################################################################

# desc()
#
# Usage:
#   desc task "description"
#
# Create a description for a specified task name. The task description text can
# be passed as the second argument or as standard input.
#
# To make the description text available to other functions, desc() assigns the
# text to a variable with the format $_desc_function_name
desc() {
  [[ -z $1 ]] && printf "desc: No task name specified.\n" && exit 1
  if [[ -n $2 ]]; then
    read -d '' "_desc_$1" <<EOM
$2
EOM
  else
    read -d '' "_desc_$1"
  fi
}

# _print_desc()
#
# Usage:
#   _print_desc <task>
#
# Prints the description for a given task, provided the description has been
# set using the desc() function.
_print_desc() {
  var="_desc_$1"
  if [[ -n ${!var} ]]; then
    printf "%s\n" "${!var}"
  else
   printf "No additional information for \`%s\`\n" "$1"
  fi
}

###############################################################################
# Default Tasks
###############################################################################

# Help ########################################################################

desc help <<EOM
Usage:
  $_me help [<task>]

Display help information for the dotfiles command or a specified task.
EOM
help() {
  if [[ $# = 0 ]]; then
    cat <<EOM
         _       _
        | |     | |
      __| | ___ | |_ ___
     / _\` |/ _ \\| __/ __|
    | (_| | (_) | |_\\__ \\
     \\__,_|\\___/ \\__|___/

Tasks for managing OS X dotfiles and environment config.

Usage:
  $_me task [<task-arguments>] [--debug]

Help:
  $_me help [<task>]

$(tasks)
EOM
 else
  _print_desc "$1"
 fi
}

# Task List ###################################################################

desc tasks <<EOM
Usage:
  $_me tasks [--raw]

Display the list of available tasks.
EOM
tasks() {
  function_list=($(declare -F))
  task_list=()
  for t in "${function_list[@]}"
  do
    if ! ( [[ $t == "declare" ]] || \
           [[ $t == "-f" ]] || \
           [[ "$t" =~ ^_(.*) ]] || \
           [[ "$t" == "desc" ]]
    ); then
      task_list+=("$t")
    fi
  done
  if _contains "--raw" "${task_options[@]}"; then
    printf "%s " "${task_list[@]}"
  else
    printf "Available tasks:\n"
    printf "  %s\n" "${task_list[@]}"
  fi
}

###############################################################################
# Tasks
# =====........................................................................
#
# Task group structure:
#
# desc example ""         - Optional. A short description for the task.
# _example_item() { : }   - Optional. The task to be run for each dotfile.
# example() { : }         - The task as it appears to the user
#
#
# desc example <<EOM
#   Example help text. Options specified with http://docopt.org/
# EOM
# _example() {
#   echo $f
#   echo $tracked_file
#   echo $filename
#   echo $original_file
# }
# example() {
#   echo ">> Listing each dotfile in repository"
#   _each_tracked_file _example
#   echo ">> Listing each dotfile in HOME"
#   _each_original_file _example
# }

###############################################################################

# init ########################################################################

desc init <<EOM
Usage:
  $_me init

Create initial repository file structure and \$HOME/bin if it doesn't exist yet.
EOM
init() {
  # Create $HOME/bin if it doesn't exist.
  [ ! -e "$HOME/bin" ] && mkdir "$HOME/bin"

  # dotfile
  if [ ! -e "$DOTFILES" ]; then
    mkdir "$DOTFILES"
    mkdir "$DOTFILES/bin"
    touch "$DOTFILES/bin/.gitkeep"
    mkdir "$DOTFILES/home"
    # No .gitkeep since all dotfiles in this directory are linked and tracked.
    mkdir "$DOTFILES/local"
    touch "$DOTFILES/local/.gitkeep"
    mkdir "$DOTFILES/script"
    mkdir "$DOTFILES/script/install"
    touch "$DOTFILES/script/install/.gitkeep"
    mkdir "$DOTFILES/script/configure"
    touch "$DOTFILES/script/configure/.gitkeep"
    mkdir "$DOTFILES/script/customize"
    touch "$DOTFILES/script/customize/.gitkeep"

    # Create the .gitignore file.
    printf "\
# Ignore the local directory, but track .gitkeep so it's included in the repo.
/local/*
!/local/.gitkeep

# Only track .ssh/config. Everything else in .ssh is private
/home/.ssh/*
!/home/.ssh/config
" >> "$DOTFILES/.gitignore"

    # initialize the dotfiles repo
    cd "$DOTFILES"
    git init

    # Print post message
    printf "\
         _       _
        | |     | |
      __| | ___ | |_ ___
     / _\` |/ _ \\| __/ __|
    | (_| | (_) | |_\\__ \\
     \\__,_|\\___/ \\__|___/

Your dotfile git repo has been initialized at the following location:

%s

To finish installation, add the following to your shell configuration (.bashrc, \
.bash_profile, .zshrc, or similar):

if [ -d \"\$HOME/bin\" ]; then
  PATH=\"\$HOME/bin:\$PATH\"
fi
" "$DOTFILES"
  fi
}

# git #########################################################################

# ------------------------------------------------------------------------- git

desc git <<EOM
Usage:
  $_me git command [<options>]

Run a git command within the \$DOTFILES directory.
EOM
git() {
  cd "$DOTFILES"

  # Must get and call $bin_path to avoid calling this function again.
  git_bin=$(which git)
  # Use raw options to get the option string, minus the `git` command.
  git_options=$(printf "%s" "$raw_options" | sed -e 's/^git //')

  # call the environment's git with the git options
  "$git_bin" "$git_options"
}

# ---------------------------------------------------------------------- commit

desc commit <<EOM
Usage:
  $_me commit [<message>]

Commit the current changes to git. If a message is provided, it will be used \
as the commit message. Otherwise, git will open your default editor.
EOM
commit() {
  cd "$DOTFILES"
  # Must get and call $bin_path to avoid calling the `git()` function above.
  git_bin=$(which git)
  if [[ -n "$1" ]]; then
    $git_bin add .
    $git_bin commit -a -m "$1"
  else
    $git_bin add .
    $git_bin commit -a
  fi
}

# ------------------------------------------------------------------------ pull

desc pull <<EOM
Usage:
  $_me pull

Pull latest changes from the remote repository.
EOM
pull() {
  cd "$DOTFILES"
  # Must get and call $bin_path to avoid calling the `git()` function above.
  git_bin=$(which git)
  if [[ -n "$1" ]]; then
    $git_bin pull
  fi
}

# ------------------------------------------------------------------------ push

desc push <<EOM
Usage:
  $_me push

Push local commits to the remote repository.
EOM
push() {
  cd "$DOTFILES"
  # Must get and call $bin_path to avoid calling the `git()` function above.
  git_bin=$(which git)
  if [[ -n "$1" ]]; then
    $git_bin push
  fi
}

# ----------------------------------------------------------- update_submodules

desc update_submodules <<EOM
Usage:
  $_me update_submodules

Update git submodules. An alias for the git command:
  git submodule foreach git pull
EOM
update_submodules() {
  cd "$DOTFILES"
  # Must get and call $bin_path to avoid calling the `git()` function above.
  git_bin=$(which git)
  $git_bin submodule foreach git pull
}

# Scripts #####################################################################

# --------------------------------------------------------------------- install

desc install <<EOM
Usage:
  $_me install ( --all | <list> | <script_name> )

Run the specified package script.

Package scripts can be added to:
  $DOTFILES/script/install/
EOM
install() {
  _runner "install" "$1"
}

# ------------------------------------------------------------------- configure

desc configure <<EOM
Usage:
  $_me configure ( --all| <configuration_script> )

Run the specified package update script.

Configuration scripts can be added to:
  $DOTFILES/script/configure/
EOM
configure() {
  _runner "configure" "$1"
}

# ------------------------------------------------------------------- customize

desc customize <<EOM
Usage: $_me customize ( --all | <customization_script> )

Run the specified customization script.

Customization scripts can be added to:
  $DOTFILES/script/customize/
EOM
customize() {
  _runner "customize" "$1"
}

# Dotfiles ####################################################################

# ------------------------------------------------------------------------ list

desc list <<EOM
Usage:
  $_me list [<filename>]
  $_me [<context>] list [<filename>]
  $_me bin list [<filename>]
  $_me home list [<filename>]

List all files in the original directory of the current context ('bin' or \
'home'). If no context is passed, the context defaults to 'home' (ie, \
dotfiles).

If 'tracked' or 'untracked' as passed as arguments to 'list', then those \
tasks are run.

If a filename is passed as an argument, then a listing is printed for only \
that item.

Indicator prefixes display information about the type and status of each entry:
  d   - Directory
  @   - Symbolic link
  @ i - Symbolic link to tracked file.

EOM
_list_item() {
  if [[ -L $f ]]; then
    if [[ "$(readlink "$f")" == "$tracked_file" ]]; then
      printf "@  i   %s\n" "$filename"
    else
      printf "@      %s\n" "$filename"
    fi
  elif [[ -d $f ]]; then
    printf "d      %s\n" "$filename"
  elif [[ -e $f ]]; then
    printf "       %s\n" "$filename"
  fi

}
list() {
  if [[ "$1" == "untracked" ]]; then
    untracked
  elif [[ "$1" == "tracked" ]]; then
    tracked
  elif [[ "$1" =~ ^\.(.*) ]]; then
    f="$original_dir/$1"
    if [[ -e "$f" ]]; then
      filename=$(basename "$f")
      tracked_file=$tracked_dir/$filename
      original_file=$original_dir/$filename
      _list_item
    else
      printf "File not found.\n" && exit 1
    fi
  else
    _each_original_file _list_item
  fi
}

# ------------------------------------------------------------------- untracked

desc untracked <<EOM
Usage:
  $_me untracked
  $_me [<context>] untracked
  $_me bin untracked
  $_me home untracked.

List all untracked dotfiles in the original directory of the current context \
('bin' or 'home'). If no context is passed, the context defaults to 'home' \
(ie, dotfiles).

Indicator prefixes display information about the type and status of each entry:
  d   - Directory
  @   - Symbolic link
EOM
_untracked_item() {
  if [[ -L $f ]];then
    if ! ( [[ "$(readlink "$f")" == "$tracked_file" ]] ); then
      printf "@      %s\n" "$filename"
    fi
  elif [[ -d $f ]]; then
    printf "d      %s\n" "$filename"
  elif [[ -e $f ]]; then
    printf "       %s\n" "$filename"
  fi
}
untracked() {
  _each_original_file _untracked_item
}

# --------------------------------------------------------------------- tracked

desc tracked <<EOM
Usage:
  $_me tracked
  $_me [<context>] tracked
  $_me bin tracked
  $_me home tracked

List all tracked dotfiles from in the original directory of the current \
context ('bin' or 'home'). If no context is passed, the context defaults \
to 'home' (ie, dotfiles).

Indicator prefixes display information about the type and status of each entry:
  @ i - Symbolic link to tracked file.
EOM
_tracked_item() {
  if ( [[ -L $f ]] && \
       [[ "$(readlink "$f")" == "$tracked_file" ]]
  ); then
    printf "@  i   %s\n" "$filename"
  fi
}
tracked() {
  _each_original_file _tracked_item
}

# ------------------------------------------------------------------------- add

desc add <<EOM
Usage:
  $_me add <filename>
  $_me [<context>] add <filename>
  $_me bin add <filename>
  $_me home add <filename>

Add the specified file to the tracked directory for the context ('bin' or \
'home') and link. If no context is passed, the context defaults to 'home' \
(ie, dotfiles).
EOM
add() {
  _debug && printf "add() \$1: %s\n" "$1"

  if [[ $# = 0 ]]; then
    printf "Must specify a valid file or directory name.\n" && exit 1
  else
    filename=$(basename "$1")

    original_file=$original_dir/$filename
    _debug && printf "add() \$original_file: %s\n" "$original_file"

    tracked_file=$tracked_dir/$filename
    _debug && printf "add() \$tracked_file: %s\n" "$tracked_file"

    if [[ ! -e $original_file ]]; then
      printf "File or directory does not exist.\n" && exit 1
    elif [[ -e $tracked_file ]]; then
      printf "File has already been added.\n"
    elif [[ -L $original_file ]]; then
      printf "Original is already a symlink.\n"
    else
      mv "$original_file" "$tracked_dir"
      printf "Linking %s => %s\n" "$tracked_file" "$original_file"
      ln -s "$tracked_file" "$original_file"
    fi
  fi
}

# --------------------------------------------------------------------- restore

desc restore <<EOM
Usage:
  $_me restore <filename>
  $_me [<context>] restore <filename>
  $_me bin restore <filename>
  $_me home restore <filename>

Unlink the specified file and move from the tracked location in the repository \
back to original location specified by the context ('bin' or 'home'). If no \
context is passed, the context defaults to 'home' (ie, dotfiles).
EOM
restore() {
  _debug && printf "restore() \$1: %s\n" "$1"

  if [[ $# = 0 ]]; then
    printf "Must specify a valid file or directory name.\n" && exit 1
  else
    filename=$(basename "$1")

    original_file=$original_dir/$filename
    _debug && printf "restore() \$original_file: %s\n" "$original_file"

    tracked_file=$tracked_dir/$filename
    _debug && printf "restore() \$tracked_file: %s\n" "$tracked_file"

    if [[ ! -e $tracked_file ]]; then
      printf "File does not exist.\n"
    elif [[ ! -L $original_file ]]; then
      printf "File is not a symlink.\n"
    else
      rm "$original_file"
      mv "$tracked_file" "$original_file"
      printf "Restored: %s => %s\n" "$tracked_file" "$original_file"
    fi
  fi
}

# ---------------------------------------------------------------------- status

desc status <<EOM
Usage:
  $_me status
  $_me [<context>] status
  $_me bin status
  $_me home status

List status of files in original directory of the current context ('bin' or \
'home')relative to the corresponding tracked file. If no context is passed, \
the context defaults to 'home' (ie, dotfiles).

Indicator prefixes display information about the status of each entry:
  i   - Identical, indicating a valid symbolic link to the tracked file
   e  - A file exists, but it not linked to tracked file
    x - No file exists
EOM
_status_item() {
  if ( [[ -L $original_file ]] && \
       [[ "$(readlink "$original_file")" == "$f" ]]
  ); then
    printf "i   %s\n" "$filename"
  elif [[ -e $original_file ]]; then
    printf " e  %s\n" "$filename"
  else
    printf "  x %s\n" "$filename"
  fi
}
status() {
  _each_tracked_file _status_item
}

# ------------------------------------------------------------------------ link

desc link <<EOM
Usage:
  $_me link [<filename>]
  $_me [<context>] link [<filename>]
  $_me bin link [<filename>]
  $_me home link [<filename>]

Create a link in the original directory for the context ('bin' or 'home') that \
references the corresponding item in the tracked directory. If no context is \
passed, the context defaults to 'home' (ie, dotfiles).

Any files or symlinks in the original directory that exist already are skipped.

By default the task links all files that exist in the tracked directory. If a \
filename is passed to the link task, then it only acts on that file.
EOM
_link_item() {
  if [[ -e $original_file ]]; then
    printf "Exists: %s\n" "$filename"
  else
    printf "Linking %s => %s\n" "$f" "$original_file"
    ln -s "$f" "$original_file"
  fi
}
link() {
  if [[ -n "$1" ]]; then
    f="$tracked_dir/$1"
    filename=$(basename "$1")
    tracked_file=$tracked_dir/$filename
    original_file=$original_dir/$filename
    if [[ -e "$tracked_file" ]]; then
      _link_item
    fi
  else
    _each_tracked_file _link_item
  fi
}

# ---------------------------------------------------------------------- unlink

desc clean <<EOM
Usage:
  $_me unlink [<filename>]
  $_me [<context>] unlink [<filename>]
  $_me bin unlink [<filename>]
  $_me home unlink [<filename>]

Remove symlinks in the original directory for the context ('bin' or 'home'). \
If no context is passed, the context defaults to 'home' (ie, dotfiles).

By default, the task removes all of the symlinks pointing to items in tracked \
directory. If a filename is passed to the unlink task, then it only acts on \
symlinks to that file.
EOM
_unlink_item() {
  if ( [[ -L $original_file ]] && \
       [[ "$(readlink "$original_file")" == "$f" ]]
  ); then
    printf "Removing link: %s\n" "$original_file"
    rm "$original_file"
  fi
}
unlink() {
  if [[ -n "$1" ]]; then
    f="$tracked_dir/$1"
    filename=$(basename "$1")
    tracked_file=$tracked_dir/$filename
    original_file=$original_dir/$filename
    _unlink_item
  else
    _each_tracked_file _unlink_item
  fi
}

# Utilties ####################################################################

desc edit <<EOM
Usage:
  $_me edit

Opens the the \$DOTFILES directory in your \$EDITOR, currently set to '$EDITOR'.
EOM
edit() {
  $EDITOR "$DOTFILES"
}

desc dir <<EOM
Usage:
  $_me dir

Prints the current value of \$DOTFILES
EOM
dir() {
  printf "%s\n" "$DOTFILES"
}

###############################################################################
# Run Program
###############################################################################

# Calling the _main function after everything has been defined.
_main
