#!/usr/bin/env bash
#
#         _       _
#        | |     | |
#      __| | ___ | |_ ___
#     / _` |/ _ \| __/ __|
#    | (_| | (_) | |_\__ \
#     \__,_|\___/ \__|___/
#
#
# A configuration management tool for your personal unix-like computer.
#
#
# Copyright Â© 2014-2015 William Melody - hi@williammelody.com

###############################################################################
# .dotsrc
###############################################################################

# If a dotsrc file exists in $HOME, source it.
dotsrc="$HOME/.dotsrc"
if [[ -e "$dotsrc" ]]; then
  source "$dotsrc"
fi

###############################################################################
# Globals
###############################################################################

DOTS_VERSION="2.1.0-alpha"

# Set dotfiles if not already set.
if [[ -z $DOTSPATH ]]; then
  DOTSPATH="$HOME/.dots"
fi

###############################################################################
# Debug
###############################################################################

# _debug()
#
# Shortcut for testing against the existence of a $debug variable. Primarily
# intended to be used before a printf statement.
#
# Usage:
#   _debug printf "Debug info"
_debug() { [[ -n "$debug" ]] && "$@"; }

###############################################################################
# Options
###############################################################################

# Get raw options for any commands that expect them.
raw_options=$*

# Initialize command options and arguments arrays.
#
# These contain any options and arguments that will be used by the commands.
# Commands handle their own argument and option checks using the created arrays.
command_options=()
command_arguments=()

while [ $# -gt 0 ]; do
  opt="$1"
  shift
  case "$opt" in
    -h|--help)
      cmd="help"
      ;;
    --version)
      cmd="version"
      ;;
    --debug)
      debug=1
      ;;
    -*|--*)
      command_options+=("$opt")
      ;;
    bin|home)
      # If an argument prior to the command name is either 'bin' or 'home', set
      # that as the context. Otherwise, if the command has already been set,
      # then any matches are assumed to be command arguments.
      if [[ -z $cmd ]]; then
        context="$opt"
      else
        command_arguments+=("$opt")
      fi
      ;;
    *)
      # The first non-context argument encountered is assumed to be the command
      # name, and all subsequent arguments are set as command arguments.
      if [[ -n $cmd ]]; then
        command_arguments+=("$opt")
      else
        cmd=$opt
      fi
      ;;
  esac
done

# If no context was set from the options, default to 'home'.
if [[ -z $context ]]; then
  context="home"
fi

_debug printf "\$context: %s\n" "$context"
_debug printf "\$cmd: %s\n" "$cmd"
_debug printf "\$raw_options: %s\n" "$raw_options"
_debug printf "\$command_options: %s\n" "${command_options[*]}"
_debug printf "\$command_arguments: %s\n" "${command_arguments[*]}"

###############################################################################
# Environment
###############################################################################

# $_me
#
# Set to the program's basename.
_me=$(basename "$0")

_debug printf "\$_me: %s\n" "$_me"

# $tracked_dir
#
# Set to either 'home' or 'bin' within the dotfiles repository, depending on
# the context.
if [[ "$context" == "bin" ]]; then
  tracked_dir=$DOTSPATH/bin
else
  tracked_dir=$DOTSPATH/home
fi

_debug printf "\$tracked_dir: %s\n" "$tracked_dir"

# $original_dir
#
# Set to either '$HOME/bin' or '$HOME', depending on the context.
if [[ "$context" == "bin" ]]; then
  original_dir=$HOME/bin
else
  original_dir=$HOME
fi

_debug printf "\$original_dir: %s\n" "$original_dir"

###############################################################################
# Main
###############################################################################

# _main()
#
# Usage:
#   _main
#
# The primary function for starting the program.
#
# NOTE: must be called at end of program after all commands have been defined.
_main() {
  # If $cmd is blank, then set to help
  if [[ -z $cmd ]]; then
    cmd="help"
  fi

  # Get the list of defined commands.
  defined_commands=($(commands --raw))

  # Run the command and pass the command arguments.
  if ( _contains "$cmd" "${defined_commands[@]}" ); then
    $cmd "${command_arguments[@]}"
  else
    printf "Unknown command: %s\n" "$cmd"
    exit 1
  fi
}

###############################################################################
# Utility Functions
###############################################################################

# _each_file()
#
# Iterate over the files in the specified directory and execute the specified
# function.
#
# Usage: _each_file directory function
_each_file() {
  per_file_function=$2
  if [[ "$context" == "home" ]]; then
    search_files="$1/.*"
  else
    search_files="$1/*"
  fi
  for f in $search_files
  do
    filename=$(basename "$f")
    tracked_file=$tracked_dir/$filename
    original_file=$original_dir/$filename
    if [[ "$context" == "home" ]]; then
      if ! ( [[ "$filename" =~ ^\.?\.$ ]] ); then
        # Subfunctions can access the variables in this function, so it's not
        # necessary to pass them as arguments.
        $per_file_function
      fi
    else
      $per_file_function
    fi
  done
}

# _runner()
#
# Run or list scripts in a specified script subdirectory.
#
# Usage: _runner subdirectory ( --all | <list> | <script_name> )
_run_script() {
  if [[ -f "$1" ]]; then
    printf ">> Running %s\n" "$(basename "$1")"
    $1
  elif [[ -d "$1" ]]; then
    printf "'%s' is a directory.\n" "$1" && exit 1
  else
    printf "'%s' not found.\n" "$1" && exit 1
  fi
}
_runner() {
  [[ -z $1 ]] && printf "_runner: No subdirectory specified.\n" && exit 1
  subdir=$1
  subdir_path=$DOTSPATH/script/$subdir
  script_file=$subdir_path/$2
  if _contains "--all" "${command_options[@]}"; then
    for f in $subdir_path/*
    do
      _run_script "$f"
    done
  elif [[ -n "$2" ]]; then
    if [[ "$2" == "list" ]]; then
      for f in $subdir_path/*
      do
        if [[ -f "$f" ]]; then
          basename "$f"
        fi
      done
    else
      _run_script "$script_file"
    fi
  else
    cat <<EOM
Script must be specified. You can see available scripts by running the \
following command:

$_me $1 list
EOM
    exit 1
  fi
}

# _each_tracked_file()
#
# Iterate over the files in the tracked directory and execute the specified
# function.
#
# Usage: _each_tracked_file function
_each_tracked_file() {
  _each_file "$tracked_dir" "$1"
}

# _each_original_file()
#
# Iterate over the files in the original directory and execute the specified
# function.
#
# Usage: _each_original_file function
_each_original_file() {
  _each_file "$original_dir" "$1"
}

# _function_exists()
#
# Takes a potential function name as an argument and returns whether a function
# exists with that name.
_function_exists() {
  [ "$(type -t "$1")" == 'function' ]
}

# _contains()
#
# Takes an item and a list and determines whether the list contains the item.
#
# Usage:
#   _contains "$item" "${list[@]}"
_contains() {
  local e
  for e in "${@:2}"; do [[ "$e" == "$1" ]] && return 0; done
  return 1
}

###############################################################################
# desc
###############################################################################

# desc()
#
# Usage:
#   desc command "description"
#
# Create a description for a specified command name. The command description
# text can be passed as the second argument or as standard input.
#
# To make the description text available to other functions, desc() assigns the
# text to a variable with the format $_desc_function_name
desc() {
  [[ -z $1 ]] && printf "desc: No command name specified.\n" && exit 1
  if [[ -n $2 ]]; then
    read -d '' "_desc_$1" <<EOM
$2
EOM
  else
    read -d '' "_desc_$1"
  fi
}

# _print_desc()
#
# Usage:
#   _print_desc <command>
#
# Prints the description for a given command, provided the description has been
# set using the desc() function.
_print_desc() {
  var="_desc_$1"
  if [[ -n ${!var} ]]; then
    printf "%s\n" "${!var}"
  else
   printf "No additional information for \`%s\`\n" "$1"
  fi
}

###############################################################################
# Default Commands
###############################################################################

# Version #####################################################################

desc version <<EOM
Usage:
  $_me version
  $_me --version

Display the current program version.

To save you the trouble, the current version is $DOTS_VERSION
EOM
version() {
  printf "%s\n" "$DOTS_VERSION"
}

# Help ########################################################################

desc help <<EOM
Usage:
  $_me help [<command>]

Display help information for the dotfiles command or a specified command
EOM
help() {
  if [[ $# = 0 ]]; then
    cat <<EOM
         _       _
        | |     | |
      __| | ___ | |_ ___
     / _\` |/ _ \\| __/ __|
    | (_| | (_) | |_\\__ \\
     \\__,_|\\___/ \\__|___/

A local configuration tool and framework.

Version: $DOTS_VERSION

Usage:
  $_me command [<command-arguments>] [--debug]

Help:
  $_me help [<command>]

$(commands)
EOM
 else
  _print_desc "$1"
 fi
}

# Command List ################################################################

desc commands <<EOM
Usage:
  $_me commands [--raw]

Display the list of available commands.
EOM
commands() {
  function_list=($(declare -F))
  command_list=()
  for c in "${function_list[@]}"
  do
    if ! ( [[ $c == "declare" ]] || \
           [[ $c == "-f" ]] || \
           [[ "$c" =~ ^_(.*) ]] || \
           [[ "$c" == "desc" ]]
    ); then
      command_list+=("$c")
    fi
  done
  if _contains "--raw" "${command_options[@]}"; then
    printf "%s " "${command_list[@]}"
  else
    printf "Available commands:\n"
    printf "  %s\n" "${command_list[@]}"
  fi
}

###############################################################################
# Commands
# ========.....................................................................
#
# Example command group structure:
#
# desc example ""         - Optional. A short description for the command.
# _example_item() { : }   - Optional. A child function to be run for each item.
# example() { : }         - The command called by the user.
#
#
# desc example <<EOM
#   Example help text. Options specified with http://docopt.org/
# EOM
# _example() {
#   echo $f
#   echo $tracked_file
#   echo $filename
#   echo $original_file
# }
# example() {
#   echo ">> Listing each dotfile in repository"
#   _each_tracked_file _example
#   echo ">> Listing each dotfile in HOME"
#   _each_original_file _example
# }

###############################################################################

# init ########################################################################

desc init <<EOM
Usage:
  $_me init [<source_repository>] [<dotspath>] [--initialize-submodules] \
[--skip-dotsrc]

Create initial repository file structure and \$HOME/bin if it doesn't exist yet.

When provided with a URL as the first argument or a second argument the git \
repository at that URL is cloned and used as the tracking repository.

When provided with full path as the lone argument or second argument after a \
repository URL, the initial repository is created at the specified path and a \
configuration file is created at \$HOME/.dotsrc with that location set as \
the \$DOTSPATH.

When the --initialize-submodules flag is used with a source repository URL,
any submodules in the repository are initialized and recursively updated.

When the --skip-dotsrc flag is used with a custom dotspath, the .dotsrc file \
is not created.
EOM
# _init_with_source()
#
# Clone a specified URL to a specified path.
#
# called by: init()
_init_with_source() {
  _debug printf "_init_with_source() \$1: %s\n" "$1"
  _debug printf "_init_with_source() \$2: %s\n" "$2"
  if [[ -z "$1" ]]; then
    printf "Repository directory not specified.\n"
  elif [[ -z "$2" ]]; then
    printf "Source URL not specified.\n"
  else
    # Must get and call $bin_path to avoid calling the `dots git` function.
    git_bin=$(which git)
    $git_bin clone "$2" "$1"
  fi

  if _contains "--initialize-submodules" "${command_options[@]}"; then
    cd "$1"
    $git_bin submodule init
    $git_bin submodule update --init --recursive
  fi
}
# _init_dotsrc()
#
# Create a file at $HOME/.dotsrc for configuration settings.
#
# called by: init()
_init_dotsrc() {
  _contains "--skip-dotsrc" "${command_options[@]}" && return 0
  if [[ -n "$1" ]]; then
    printf "\
# .dotsrc
#
# Configuration file for dots
#
# https://github.com/alphabetum/dots

# Set dots directory
export DOTSPATH=\"%s\"
" "$1" >> "$HOME/.dotsrc"
  else
    printf "Repository location not specified.\n"
  fi
}
# _init_directory_structure()
#
# Create an initial directory structure at $DOTSPATH
#
# called by: init()
_init_directory_structure() {
  if [[ -n "$1" ]]; then
    mkdir "$1"
    mkdir "$1/bin"
    touch "$1/bin/.gitkeep"
    mkdir "$1/home"
    # No .gitkeep since all dotfiles in this directory are linked and tracked.
    mkdir "$1/local"
    touch "$1/local/.gitkeep"
    mkdir "$1/script"
    mkdir "$1/script/install"
    touch "$1/script/install/.gitkeep"
    mkdir "$1/script/configure"
    touch "$1/script/configure/.gitkeep"
    mkdir "$1/script/customize"
    touch "$1/script/customize/.gitkeep"
  else
    printf "Repository directory not specified.\n"
  fi
}
# _init_gitignore()
#
# Add the default .gitignore to $DOTSPATH/.gitignore
#
# called by: init()
_init_gitignore() {
  if [[ -n "$1" ]]; then
    printf "\
# Ignore the local directory, but track .gitkeep so it's included in the repo.
/local/*
!/local/.gitkeep

# Only track .ssh/config. Everything else in .ssh is private
/home/.ssh/*
!/home/.ssh/config
" >> "$1/.gitignore"
  else
    printf "Repository directory not specified.\n"
  fi
}
# _init_git_repository()
#
# Initialize the git repository at $DOTSPATH
#
# called by: init()
_init_git_repository() {
  if [[ -n "$1" ]]; then
    cd "$1"
    # Must get and call $bin_path to avoid calling the `dots git` function.
    git_bin=$(which git)
    $git_bin init
  else
    printf "Repository directory not specified.\n"
  fi
}
# _init_post_message()
#
# Print information about what just happened and some next steps.
#
# called by: init()
_init_post_message() {
  if [[ -n "$1" ]]; then
    printf "\
         _       _
        | |     | |
      __| | ___ | |_ ___
     / _\` |/ _ \\| __/ __|
    | (_| | (_) | |_\\__ \\
     \\__,_|\\___/ \\__|___/

Your dotfile git repo has been initialized at the following location:

%s

To finish installation, add the following to your shell configuration (.bashrc, \
.bash_profile, .zshrc, or similar):

if [ -d \"\$HOME/bin\" ]; then
  PATH=\"\$HOME/bin:\$PATH\"
fi
" "$1"
  else
    printf "Repository directory not specified.\n"
  fi
}
# init()
#
# Initialize a new repository.
init() {
  # Initialize variables
  #
  # $init_souce: will be set to a source git repository URL if available.
  init_source=
  # A URL-matching regex to check arguments for a source git repository.
  _regex='(https?|git|ssh|file)://[-A-Za-z0-9\+&@#/%?=~_|!:,.;]*[-A-Za-z0-9\+&@#/%=~_|]'

  # Create $HOME/bin if it doesn't exist.
  if [[ ! -e "$HOME/bin" ]]; then
    mkdir "$HOME/bin"
  fi

  # Handle arguments.
  #
  # Expected behavior:
  #   init [<source_repository>] [<dotspath>]
  if [[ -n "$1" ]]; then
    if [[ "$1" =~ $_regex ]]; then
      init_source="$1"
      if [[ -n "$2" ]]; then
        DOTSPATH="$2"
        _init_dotsrc "$DOTSPATH"
      fi
    else
      DOTSPATH="$1"
      _init_dotsrc "$DOTSPATH"
    fi
  fi
  _debug printf "init() \$DOTSPATH: %s\n" "$DOTSPATH"
  _debug printf "init() \$init_source: %s\n" "$init_source"

  # Initialize either from source or with fresh directory structure.
  if [[ ! -e "$DOTSPATH" ]]; then
    if [[ -n "$init_source" ]]; then
      _init_with_source "$DOTSPATH" "$init_source"
    else
      _init_directory_structure "$DOTSPATH"
      _init_gitignore "$DOTSPATH"
      _init_git_repository "$DOTSPATH"
    fi
    _init_post_message "$DOTSPATH"
  fi
}

# git #########################################################################

# ------------------------------------------------------------------------- git

desc git <<EOM
Usage:
  $_me git command [<options>]

Run a git command within the \$DOTSPATH directory.
EOM
git() {
  cd "$DOTSPATH"
  # Must get and call $bin_path to avoid calling this function again.
  git_bin=$(which git)
  # Use raw options to get the option string, minus the `git` command.
  git_options=$(printf "%s" "$raw_options" | sed -e 's/^git //')

  # call the environment's git with the git options
  "$git_bin" "$git_options"
}

# ---------------------------------------------------------------------- commit

desc commit <<EOM
Usage:
  $_me commit [<message>]

Commit the current changes to git. If a message is provided, it will be used \
as the commit message. Otherwise, git will open your default editor.
EOM
commit() {
  cd "$DOTSPATH"
  # Must get and call $bin_path to avoid calling the `git()` function above.
  git_bin=$(which git)
  if [[ -n "$1" ]]; then
    $git_bin add .
    $git_bin commit -a -m "$1"
  else
    $git_bin add .
    $git_bin commit -a
  fi
}

# ------------------------------------------------------------------------ pull

desc pull <<EOM
Usage:
  $_me pull

Pull latest changes from the remote repository.
EOM
pull() {
  cd "$DOTSPATH"
  # Must get and call $bin_path to avoid calling the `git()` function above.
  git_bin=$(which git)
  $git_bin pull
  _debug printf "%s pull\n" "$git_bin"
}

# ------------------------------------------------------------------------ push

desc push <<EOM
Usage:
  $_me push

Push local commits to the remote repository.
EOM
push() {
  cd "$DOTSPATH"
  # Must get and call $bin_path to avoid calling the `git()` function above.
  git_bin=$(which git)
  $git_bin push
  _debug printf "%s push\n" "$git_bin"
}

# ----------------------------------------------------------- update_submodules

desc update_submodules <<EOM
Usage:
  $_me update_submodules

Update git submodules. An alias for the git command:
  git submodule foreach git pull
EOM
update_submodules() {
  cd "$DOTSPATH"
  # Must get and call $bin_path to avoid calling the `git()` function above.
  git_bin=$(which git)
  $git_bin submodule foreach git pull
}

# Scripts #####################################################################

# --------------------------------------------------------------------- install

desc install <<EOM
Usage:
  $_me install ( --all | <list> | <script_name> )

Run the specified package script.

Package scripts can be added to:
  $DOTSPATH/script/install/
EOM
install() {
  _runner "install" "$1"
}

# ------------------------------------------------------------------- configure

desc configure <<EOM
Usage:
  $_me configure ( --all | <configuration_script> )

Run the specified package update script.

Configuration scripts can be added to:
  $DOTSPATH/script/configure/
EOM
configure() {
  _runner "configure" "$1"
}

# ------------------------------------------------------------------- customize

desc customize <<EOM
Usage: $_me customize ( --all | <customization_script> )

Run the specified customization script.

Customization scripts can be added to:
  $DOTSPATH/script/customize/
EOM
customize() {
  _runner "customize" "$1"
}

# Dotfiles ####################################################################

# ------------------------------------------------------------------------ list

desc list <<EOM
Usage:
  $_me list [<filename>]
  $_me [<context>] list [<filename>]
  $_me bin list [<filename>]
  $_me home list [<filename>]

List all files in the original directory of the current context ('bin' or \
'home'). If no context is passed, the context defaults to 'home' (ie, \
dotfiles).

If 'tracked' or 'untracked' as passed as arguments to 'list', then those \
commands are run.

If a filename is passed as an argument, then a listing is printed for only \
that item.

Indicator prefixes display information about the type and status of each entry:
  d   - Directory
  @   - Symbolic link
  @ i - Symbolic link to tracked file.

EOM
_list_item() {
  if [[ -L $f ]]; then
    if [[ "$(readlink "$f")" == "$tracked_file" ]]; then
      printf "@  i   %s\n" "$filename"
    else
      printf "@      %s\n" "$filename"
    fi
  elif [[ -d $f ]]; then
    printf "d      %s\n" "$filename"
  elif [[ -e $f ]]; then
    printf "       %s\n" "$filename"
  fi

}
list() {
  if [[ "$1" == "untracked" ]]; then
    untracked
  elif [[ "$1" == "tracked" ]]; then
    tracked
  elif [[ "$1" =~ ^\.(.*) ]]; then
    f="$original_dir/$1"
    if [[ -e "$f" ]]; then
      filename=$(basename "$f")
      tracked_file=$tracked_dir/$filename
      original_file=$original_dir/$filename
      _list_item
    else
      printf "File not found.\n" && exit 1
    fi
  else
    _each_original_file _list_item
  fi
}

# ------------------------------------------------------------------- untracked

desc untracked <<EOM
Usage:
  $_me untracked
  $_me [<context>] untracked
  $_me bin untracked
  $_me home untracked.

List all untracked dotfiles in the original directory of the current context \
('bin' or 'home'). If no context is passed, the context defaults to 'home' \
(ie, dotfiles).

Indicator prefixes display information about the type and status of each entry:
  d   - Directory
  @   - Symbolic link
EOM
_untracked_item() {
  if [[ -L $f ]];then
    if ! ( [[ "$(readlink "$f")" == "$tracked_file" ]] ); then
      printf "@      %s\n" "$filename"
    fi
  elif [[ -d $f ]]; then
    printf "d      %s\n" "$filename"
  elif [[ -e $f ]]; then
    printf "       %s\n" "$filename"
  fi
}
untracked() {
  _each_original_file _untracked_item
}

# --------------------------------------------------------------------- tracked

desc tracked <<EOM
Usage:
  $_me tracked
  $_me [<context>] tracked
  $_me bin tracked
  $_me home tracked

List all tracked dotfiles from in the original directory of the current \
context ('bin' or 'home'). If no context is passed, the context defaults \
to 'home' (ie, dotfiles).

Indicator prefixes display information about the type and status of each entry:
  @ i - Symbolic link to tracked file.
EOM
_tracked_item() {
  if ( [[ -L $f ]] && \
       [[ "$(readlink "$f")" == "$tracked_file" ]]
  ); then
    printf "@  i   %s\n" "$filename"
  fi
}
tracked() {
  _each_original_file _tracked_item
}

# ------------------------------------------------------------------------- add

desc add <<EOM
Usage:
  $_me add <filename>
  $_me [<context>] add <filename>
  $_me bin add <filename>
  $_me home add <filename>

Add the specified file to the tracked directory for the context ('bin' or \
'home') and link. If no context is passed, the context defaults to 'home' \
(ie, dotfiles).
EOM
add() {
  _debug printf "add() \$1: %s\n" "$1"

  if [[ $# = 0 ]]; then
    printf "Must specify a valid file or directory name.\n" && exit 1
  else
    filename=$(basename "$1")

    original_file=$original_dir/$filename
    _debug printf "add() \$original_file: %s\n" "$original_file"

    tracked_file=$tracked_dir/$filename
    _debug printf "add() \$tracked_file: %s\n" "$tracked_file"

    if [[ ! -e $original_file ]]; then
      printf "File or directory does not exist.\n" && exit 1
    elif [[ -e $tracked_file ]]; then
      printf "File has already been added.\n"
    elif [[ -L $original_file ]]; then
      printf "Original is already a symlink.\n"
    else
      mv "$original_file" "$tracked_dir"
      printf "Linking %s => %s\n" "$tracked_file" "$original_file"
      ln -s "$tracked_file" "$original_file"
    fi
  fi
}

# --------------------------------------------------------------------- restore

desc restore <<EOM
Usage:
  $_me restore <filename>
  $_me [<context>] restore <filename>
  $_me bin restore <filename>
  $_me home restore <filename>

Unlink the specified file and move from the tracked location in the repository \
back to original location specified by the context ('bin' or 'home'). If no \
context is passed, the context defaults to 'home' (ie, dotfiles).
EOM
restore() {
  _debug printf "restore() \$1: %s\n" "$1"

  if [[ $# = 0 ]]; then
    printf "Must specify a valid file or directory name.\n" && exit 1
  else
    filename=$(basename "$1")

    original_file=$original_dir/$filename
    _debug printf "restore() \$original_file: %s\n" "$original_file"

    tracked_file=$tracked_dir/$filename
    _debug printf "restore() \$tracked_file: %s\n" "$tracked_file"

    if [[ ! -e $tracked_file ]]; then
      printf "File does not exist.\n"
    elif [[ ! -L $original_file ]]; then
      printf "File is not a symlink.\n"
    else
      rm "$original_file"
      mv "$tracked_file" "$original_file"
      printf "Restored: %s => %s\n" "$tracked_file" "$original_file"
    fi
  fi
}

# ---------------------------------------------------------------------- status

desc status <<EOM
Usage:
  $_me status
  $_me [<context>] status
  $_me bin status
  $_me home status

List status of files in original directory of the current context ('bin' or \
'home')relative to the corresponding tracked file. If no context is passed, \
the context defaults to 'home' (ie, dotfiles).

Indicator prefixes display information about the status of each entry:
  i   - Identical, indicating a valid symbolic link to the tracked file
   e  - A file exists, but it not linked to tracked file
    x - No file exists
EOM
_status_item() {
  if ( [[ -L $original_file ]] && \
       [[ "$(readlink "$original_file")" == "$f" ]]
  ); then
    printf "i   %s\n" "$filename"
  elif [[ -e $original_file ]]; then
    printf " e  %s\n" "$filename"
  else
    printf "  x %s\n" "$filename"
  fi
}
status() {
  _each_tracked_file _status_item
}

# ------------------------------------------------------------------------ link

desc link <<EOM
Usage:
  $_me link [<filename>] [--overwrite [--with-backup]]
  $_me [<context>] link [<filename>] [--overwrite [--with-backup]]
  $_me bin link [<filename>] [--overwrite [--with-backup]]
  $_me home link [<filename>] [--overwrite [--with-backup]]

Create a link in the original directory for the context ('bin' or 'home') that \
references the corresponding item in the tracked directory. If no context is \
passed, the context defaults to 'home' (ie, dotfiles).

Any files or symlinks in the original directory that exist already are skipped \
unless the --overwrite option is used, in which case any existing files are \
deleted and links are then created as usual.

When the --with-backup flag is uses in combination with --overwrite, any \
overwritten files are first renamed with a .bak extension. If a file with the \
same name plus .bak extension exists, it is skipped altogether.

By default the command links all files that exist in the tracked directory. \
If a filename is passed to the link command, then it only acts on that file.
EOM
_link_item() {
  if [[ -e $original_file ]]; then
    if _contains "--overwrite" "${command_options[@]}"; then
      if _contains "--with-backup" "${command_options[@]}"; then
        if [[ -e "$original_file".bak ]]; then
          printf "Exists with .bak: %s, %s\n" "$filename" "$filename".bak
          return 1
        else
          mv "$original_file" "$original_file".bak
        fi
      else
        rm "$original_file"
      fi
    else
      printf "Exists: %s\n" "$filename"
      return 1
    fi
  fi
  printf "Linking %s => %s\n" "$f" "$original_file"
  ln -s "$f" "$original_file"
}
link() {
  if [[ -n "$1" ]]; then
    f="$tracked_dir/$1"
    filename=$(basename "$1")
    tracked_file=$tracked_dir/$filename
    original_file=$original_dir/$filename
    if [[ -e "$tracked_file" ]]; then
      _link_item
    fi
  else
    _each_tracked_file _link_item
  fi
}

# ---------------------------------------------------------------------- unlink

desc unlink <<EOM
Usage:
  $_me unlink [<filename>]
  $_me [<context>] unlink [<filename>]
  $_me bin unlink [<filename>]
  $_me home unlink [<filename>]

Remove symlinks in the original directory for the context ('bin' or 'home'). \
If no context is passed, the context defaults to 'home' (ie, dotfiles).

By default, the command removes all of the symlinks pointing to items in \
tracked directory. If a filename is passed to the unlink command, then it \
only acts on symlinks to that file.
EOM
_unlink_item() {
  if ( [[ -L $original_file ]] && \
       [[ "$(readlink "$original_file")" == "$f" ]]
  ); then
    printf "Removing link: %s\n" "$original_file"
    rm "$original_file"
  fi
}
unlink() {
  if [[ -n "$1" ]]; then
    f="$tracked_dir/$1"
    filename=$(basename "$1")
    tracked_file=$tracked_dir/$filename
    original_file=$original_dir/$filename
    _unlink_item
  else
    _each_tracked_file _unlink_item
  fi
}

# ---------------------------------------------------------------------- rename

desc rename <<EOM
Usage:
  $_me [<context>] rename <old_filename> <new_filename>

Rename a tracked file and its corresponding link.
EOM
rename() {
  old_file=$tracked_dir/$1
  _debug printf "rename() \$old_file: %s\n" "$old_file"
  new_file=$tracked_dir/$2
  _debug printf "rename() \$new_file: %s\n" "$new_file"

  if [[ -z "$1" ]]; then
    printf "Filename not provided.\n"
  elif [[ -z "$2" ]]; then
    printf "New name not provided.\n"
  elif ! ( [[ -e "$old_file" ]] ); then
    printf "File not found.\n"
  elif ( [[ -e "$new_file" ]] ); then
    printf "A file already exists with the new filename.\n"
  else
    unlink "$1"
    _debug printf "unlink %s\n" "$1"

    mv "$old_file" "$new_file"
    _debug printf "mv %s %s\n" "$old_file" "$new_file"

    link "$2"
    _debug printf "link %s\n" "$2"
  fi
}

# Utilties ####################################################################

desc edit <<EOM
Usage:
  $_me edit

Opens the the \$DOTSPATH directory in your \$EDITOR, currently set to '$EDITOR'.
EOM
edit() {
  $EDITOR "$DOTSPATH"
}

desc dir <<EOM
Usage:
  $_me dir

Prints the current value of \$DOTSPATH
EOM
dir() {
  printf "%s\n" "$DOTSPATH"
}

###############################################################################
# Run Program
###############################################################################

# Calling the _main function after everything has been defined.
_main
    git_bin=$(which git)
