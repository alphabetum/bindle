#!/usr/bin/env bash
#
#         _       _
#        | |     | |
#      __| | ___ | |_ ___
#     / _` |/ _ \| __/ __|
#    | (_| | (_) | |_\__ \
#     \__,_|\___/ \__|___/
#
#
# A local configuration framework.
#
# Example task group:
#
# desc example ""         - Optional. A short description for the task.
# _example_item() { : }   - Optional. The task to be run for each dotfile.
# example() { : }         - The task as it appears to the user
#
#
# desc example <<EOM
#   Example help text.
# EOM
# _example() {
#   echo $f
#   echo $source_file
#   echo $filename
#   echo $target_file
# }
# example() {
#   echo ">> Listing each dotfile in repository"
#   _each_dotfile _example
#   echo ">> Listing each dotfile in HOME"
#   _each_target_dotfile _example
# }


###############################################################################
# Environment
###############################################################################

# $_me
#
# Set to the command's basename.
_me=$(basename "$0")


# Ensure that $DOTFILES is set in the environment.
if [[ -z $DOTFILES ]]; then
  printf "\$DOTFILES must be set to your dotfiles directory\n" && exit 1
fi

# $source_dir
#
# Set to a 'home' directory adjacent to this command's enclosing directory.
source_dir=$DOTFILES/home

# $target_dir
#
# Set to $HOME in the environment.
target_dir=$HOME


###############################################################################
# Options
###############################################################################

# Get raw options for any tasks that expect them.
raw_options=$*

# Initialize task options and arguments arrays.
#
# These contain any options and arguments that will be used by the tasks.
# Tasks handle their own argument and option checks using the created arrays.
task_options=()
task_arguments=()

while [ $# -gt 0 ]; do
  opt="$1"
  shift
  case "$opt" in
    -h|--help)
      command="help"
      ;;
    -*|--*)
      task_options+=("$opt")
      ;;
    *)
      if [[ -n $command ]]; then
        task_arguments+=("$opt")
      else
        command=$opt
      fi
      ;;
  esac
done

###############################################################################
# Utility functions
###############################################################################

# desc()
#
# Usage:
#   desc task "description"
#
# Create a description for a specified task name. The task description text can
# be passed as the second argument or as standard input.
#
# To make the description text available to other functions, desc() assigns the
# text to a variable with the format $_desc_function_name
desc() {
  [[ -z $1 ]] && printf "desc: No task name specified.\n" && exit 1
  if [[ -n $2 ]]; then
    read -d '' "_desc_$1" <<EOM
$2
EOM
  else
    read -d '' "_desc_$1"
  fi
}

# _each_file()
#
# Iterate over the files in the specified directory and execute the specified
# function.
#
# Usage: _each_file directory function
_each_file() {
  per_file_function=$2
  for f in $1/.*
  do
    filename=$(basename "$f")
    source_file=$source_dir/$filename
    target_file=$target_dir/$filename
    if ! ( [[ "$filename" =~ ^\.?\.$ ]] ); then
      # Subfunctions can access the variables in this function, so it's not
      # necessary to pass them as arguments.
      $per_file_function
    fi
  done
}

# _runner()
#
# Run scripts in a specified script subdirectory.
#
# Usage: _runner subdirectory command
_run_script() {
  if [[ -e "$1" ]]; then
    printf ">> Running %s\n" "$(basename "$1")"
    $1
  else
    printf "'%s' not found.\n" "$1" && exit 1
  fi
}
_runner() {
  [[ -z $1 ]] && printf "_runner: No subdirectory specified.\n" && exit 1
  subdir=$1
  subdir_path=$DOTFILES/script/$subdir
  script_file=$subdir_path/$2
  if _contains "--all" "${task_options[@]}"; then
    for f in $subdir_path/*
    do
      _run_script "$f"
    done
  elif [[ -n "$2" ]]; then
    if [[ "$2" == "list" ]]; then
      for f in $subdir_path/*
      do
        basename "$f"
      done
    else
      _run_script "$script_file"
    fi
  else
    cat <<EOM
Script must be specified. You can see available scripts by running the following command:

$_me $1 list
EOM
    exit 1
  fi
}

# _each_dotfile()
#
# Iterate over the files in the source directory and execute the specified
# function.
#
# Usage: _each_dotfile function
_each_dotfile() {
  _each_file "$source_dir" "$1"
}

# _each_target_dotfile()
#
# Iterate over the files in the target directory and execute the specified
# function.
#
# Usage: _each_target_dotfile function
_each_target_dotfile() {
  _each_file "$target_dir" "$1"
}

# _function_exists()
#
# Takes a potential function name as an argument and returns whether a function
# exists with that name.
_function_exists() {
  [ "$(type -t "$1")" == 'function' ]
}

# _contains()
#
# Takes an item and a list and determines whether the list contains the item.
#
# Usage:
#   _contains "$item" "${list[@]}"
_contains() {
  local e
  for e in "${@:2}"; do [[ "$e" == "$1" ]] && return 0; done
  return 1
}

###############################################################################
# Tasks
###############################################################################

# git #########################################################################

# ------------------------------------------------------------------------- git

desc git <<EOM
Usage: $_me git [options]

Run a git command within the \$DOTFILES directory.
EOM
git() {
  cd "$DOTFILES"

  # Must get and call $bin_path to avoid calling this function again.
  git_bin=$(which git)
  # Use raw options to get the option string, minus the `git` command.
  git_options=$(printf "%s" "$raw_options" | sed -e 's/^git //')

  # call the environment's git with the git options
  "$git_bin" "$git_options"
}

# ----------------------------------------------------------- update_submodules

desc update_submodules <<EOM
Usage: $_me update_submodules

Update git submodules. An alias for the git command:
  git submodule foreach git pull
EOM
update_submodules() {
  git submodule foreach git pull
}

# Scripts #####################################################################

# --------------------------------------------------------------------- install

desc install <<EOM
Usage: $_me install [list] [--all] [package_script]

Run the specified package script.

Package scripts can be added to:
  $DOTFILES/script/install/
EOM
install() {
  _runner "install" "$1"
}

# ------------------------------------------------------------------- configure

desc configure <<EOM
Usage: $_me configure [--all] [configuration_script]

Run the specified package update script.

Configuration scripts can be added to:
  $DOTFILES/script/configure/
EOM
configure() {
  _runner "configure" "$1"
}

# ------------------------------------------------------------------- customize

desc customize <<EOM
Usage: $_me customize [--all] [customization_script]

Run the specified customization script.

Customization scripts can be added to:
  $DOTFILES/script/customize/
EOM
customize() {
  _runner "customize" "$1"
}

# Dotfiles ####################################################################

# ------------------------------------------------------------------------ list

desc list <<EOM
Usage: $_me list [filename]

List all dotfiles from in the home directory.

If 'tracked' or 'untracked' as passed as arguments to 'list', then those tasks are run.

If a dotfile name is passed as the second argument, then a listing is printed for that item.

Indicator prefixes display information about the type and status of each entry:
  d   - Directory
  @   - Symbolic link
  @ i - Symbolic link to tracked file.
EOM
_list_item() {
  if [[ -L $f ]]; then
    if [[ "$(readlink "$f")" == "$source_file" ]]; then
      printf "@  i   %s\n" "$filename"
    else
      printf "@      %s\n" "$filename"
    fi
  elif [[ -d $f ]]; then
    printf "d      %s\n" "$filename"
  elif [[ -e $f ]]; then
    printf "       %s\n" "$filename"
  fi

}
list() {
  if [[ "$1" == "untracked" ]]; then
    untracked
  elif [[ "$1" == "tracked" ]]; then
    tracked
  elif [[ "$1" =~ ^\.(.*) ]]; then
    f="$target_dir/$1"
    if [[ -e "$f" ]]; then
      filename=$(basename "$f")
      source_file=$source_dir/$filename
      target_file=$target_dir/$filename
      _list_item
    else
      printf "File not found.\n" && exit 1
    fi
  else
    _each_target_dotfile _list_item
  fi
}

# ------------------------------------------------------------------- untracked

desc untracked <<EOM
Usage: $_me untracked

List all untracked dotfiles from in the home directory.

Indicator prefixes display information about the type and status of each entry:
  d   - Directory
  @   - Symbolic link
EOM
_untracked_item() {
  if [[ -L $f ]];then
    if ! ( [[ "$(readlink "$f")" == "$source_file" ]] ); then
      printf "@      %s\n" "$filename"
    fi
  elif [[ -d $f ]]; then
    printf "d      %s\n" "$filename"
  elif [[ -e $f ]]; then
    printf "       %s\n" "$filename"
  fi
}
untracked() {
  _each_target_dotfile _untracked_item
}

# --------------------------------------------------------------------- tracked

desc tracked <<EOM
Usage: $_me tracked

List all tracked dotfiles from in the home directory.

Indicator prefixes display information about the type and status of each entry:
  @ i - Symbolic link to tracked file.
EOM
_tracked_item() {
  if ( [[ -L $f ]] && \
       [[ "$(readlink "$f")" == "$source_file" ]]
  ); then
    printf "@  i   %s\n" "$filename"
  fi
}
tracked() {
  _each_target_dotfile _tracked_item
}

# ------------------------------------------------------------------------- add

desc add <<EOM
Usage: $_me add filename

Add the specified dotfile to the dotfiles repository and link.
EOM
add() {
  if [[ $# = 0 ]]; then
    printf "Must specify a valid file or directory name.\n" && exit 1
  elif [[ ! -e $1 ]]; then
    printf "File or directory does not exist.\n" && exit 1
  else
    filename=$(basename "$1")
    target_file=$target_dir/$filename
    source_file=$source_dir/$filename
    if [[ ! -e $source_file ]]; then
      printf "File does not exist.\n"
    elif [[ ! -L $target_file ]]; then
      printf "File is not a symlink.\n"
    else
      mv "$target_file" "$source_dir"
      printf "Linking %s => %s\n" "$source_file" "$target_file"
      ln -s "$source_file" "$target_file"
    fi
  fi
}

# --------------------------------------------------------------------- restore

desc restore <<EOM
Usage: $_me restore filename

Unlink the specified file and move from the dotfiles repository back to $HOME"
EOM
restore() {
  if [[ $# = 0 ]]; then
    printf "Must specify a valid file or directory name.\n" && exit 1
  elif [[ ! -e $1 ]]; then
    printf "File or directory does not exist.\n" && exit 1
  else
    filename=$(basename "$1")
    target_file=$target_dir/$filename
    source_file=$source_dir/$filename
    if [[ ! -e $source_file ]]; then
      printf "File does not exist.\n"
    elif [[ ! -L $target_file ]]; then
      printf "File is not a symlink.\n"
    else
      rm "$target_file"
      mv "$source_file" "$target_file"
      printf "Restored: %s => %s\n" "$source_file" "$target_file"
    fi
  fi
}

# ---------------------------------------------------------------------- status

desc status <<EOM
Usage: $_me status

List status of added dotfiles relative to the corresponding tracked file.

Indicator prefixes display information about the status of each entry:
  i   - Identical, indicating a valid symbolic link to the tracked file
   e  - A file exists, but it not linked to tracked file
    x - No file exists
EOM
_status_item() {
  if ( [[ -L $target_file ]] && \
       [[ "$(readlink "$target_file")" == "$f" ]]
  ); then
    printf "i   %s\n" "$filename"
  elif [[ -e $target_file ]]; then
    printf " e  %s\n" "$filename"
  else
    printf "  x %s\n" "$filename"
  fi
}
status() {
  _each_dotfile _status_item
}

# ------------------------------------------------------------------------ link

desc link <<EOM
Usage: $_me link [filename]

Link dotfiles to home directory. Existing files skipped.

If a filename is passed to the link task, then it only acts on that file.
EOM
_link_item() {
  if [[ -e $target_file ]]; then
    printf "Exists: %s\n" "$filename"
  else
    printf "Linking %s => %s\n" "$f" "$target_file"
    ln -s "$f" "$target_file"
  fi
}
link() {
  if [[ -n "$1" ]]; then
    f="$source_dir/$1"
    filename=$(basename "$1")
    source_file=$source_dir/$filename
    target_file=$target_dir/$filename
    if [[ -e "$source_file" ]]; then
      _link_item
    fi
  else
    _each_dotfile _link_item
  fi
}

# ---------------------------------------------------------------------- unlink

desc clean <<EOM
Usage: $_me unlink [filename]

Remove dotfile links in home directory with status 'i'

If a filename is passed to the unlink task, then it only acts on that file.
EOM
_unlink_item() {
  if ( [[ -L $target_file ]] && \
       [[ "$(readlink "$target_file")" == "$f" ]]
  ); then
    printf "Removing link: %s\n" "$target_file"
    rm "$target_file"
  fi
}
unlink() {
  if [[ -n "$1" ]]; then
    f="$source_dir/$1"
    filename=$(basename "$1")
    source_file=$source_dir/$filename
    target_file=$target_dir/$filename
    _unlink_item
  else
    _each_dotfile _unlink_item
  fi
}

# Utilties ####################################################################

desc edit <<EOM
Usage: $_me edit

Opens the the dotfiles directory in your \$EDITOR, currently set to '$EDITOR'.
EOM
edit() {
  $EDITOR "$DOTFILES"
}

desc dir <<EOM
Usage: $_me dir

Prints the current value of \$DOTFILES
EOM
dir() {
  printf "%s\n" "$DOTFILES"
}

# Help ########################################################################

desc help <<EOM
Usage: $_me help [task]

Display help information for the dotfiles command or a specified task.
EOM
help() {
  if [[ $# = 0 ]]; then
    cat <<EOM
         _       _
        | |     | |
      __| | ___ | |_ ___
     / _\` |/ _ \\| __/ __|
    | (_| | (_) | |_\\__ \\
     \\__,_|\\___/ \\__|___/

Tasks for managing OS X dotfiles and environment config.

Usage:
  $_me [task]

Task help:
  $_me help [task]

$(tasks)
EOM
 else
   var="_desc_$1"
   if [[ -n ${!var} ]]; then
     printf "%s\n" "${!var}"
   else
    printf "No additional information for \`%s\`\n" "$1"
   fi
 fi
}

# Task List ###################################################################

desc tasks <<EOM
Usage: $_me tasks [--raw]

Display the list of available tasks.
EOM
tasks() {
  function_list=($(declare -F))
  task_list=()
  for t in "${function_list[@]}"
  do
    if ! ( [[ $t == "declare" ]] || \
           [[ $t == "-f" ]] || \
           [[ "$t" =~ ^_(.*) ]] || \
           [[ "$t" == "desc" ]]
    ); then
      task_list+=("$t")
    fi
  done
  if _contains "--raw" "${task_options[@]}"; then
    printf "%s " "${task_list[@]}"
  else
    printf "Available tasks:\n"
    printf "  %s\n" "${task_list[@]}"
  fi
}


###############################################################################
# Main
###############################################################################

# If $command is blank, then set to help
if [[ -z $command ]]; then
  command="help"
fi

# Get the list of defined tasks.
defined_tasks=($(tasks --raw))

# Run the command and pass the task arguments.
if ( _contains "$command" "${defined_tasks[@]}" ); then
  $command "${task_arguments[@]}"
else
  printf "Unknown command: %s\n" "$command"
  exit 1
fi

