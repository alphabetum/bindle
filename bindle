#!/usr/bin/env bash
#
#  _____  ___  _____  _____  ____   _____
# /  _  \/___\/  _  \|  _  \/  _/  /   __\
# |  _  <|   ||  |  ||  |  ||  |---|   __|
# \_____/\___/\__|__/|_____/\_____/\_____/
#
#
# A configuration management tool for your personal unix-like computer.
#
# Copyright (c) 2015 William Melody • hi@williammelody.com

###############################################################################
# Strict Mode
###############################################################################

# Treat unset variables and parameters other than the special parameters ‘@’ or
# ‘*’ as an error when performing parameter expansion. An 'unbound variable'
# error message will be written to the standard error, and a non-interactive
# shell will exit.
#
# This requires using parameter expansion to test for unset variables.
#
# http://www.gnu.org/software/bash/manual/bashref.html#Shell-Parameter-Expansion
#
# The two approaches that are probably the most appropriate are:
#
# ${parameter:-word}
#   If parameter is unset or null, the expansion of word is substituted.
#   Otherwise, the value of parameter is substituted. In other words, "word"
#   acts as a default value when the value of "$parameter" is blank. If "word"
#   is not present, then the default is blank (essentially an empty string).
#
# ${parameter:?word}
#   If parameter is null or unset, the expansion of word (or a message to that
#   effect if word is not present) is written to the standard error and the
#   shell, if it is not interactive, exits. Otherwise, the value of parameter
#   is substituted.
#
# Examples
# ========
#
# Arrays:
#
#   ${some_array[@]:-}              # blank default value
#   ${some_array[*]:-}              # blank default value
#   ${some_array[0]:-}              # blank default value
#   ${some_array[0]:-default_value} # default value: the string 'default_value'
#
# Postitional variables:
#
#   ${1:-alternative} # default value: the string 'alternative'
#   ${2:-}            # blank default value
#
# With an error message:
#
#   ${1:?'error message'}  # exit with 'error message' if variable is unbound
#
# Short form: set -u
set -o nounset

# Exit immediately if a pipeline returns non-zero.
#
# NOTE: this has issues. When using read -rd '' with a heredoc, the exit
# status is non-zero, even though there isn't an error, and this setting
# then causes the script to exit. read -rd '' is synonymous to read -d $'\0',
# which means read until it finds a NUL byte, but it reaches the EOF (end of
# heredoc) without finding one and exits with a 1 status. Therefore, when
# reading from heredocs with set -e, there are three potential solutions:
#
# Solution 1. set +e / set -e again:
#
# set +e
# read -rd '' variable <<EOF
# EOF
# set -e
#
# Solution 2. <<EOF || true:
#
# read -rd '' variable <<EOF || true
# EOF
#
# Solution 3. Don't use set -e or set -o errexit at all.
#
# More information:
#
# https://www.mail-archive.com/bug-bash@gnu.org/msg12170.html
#
# Short form: set -e
set -o errexit

# Return value of a pipeline is the value of the last (rightmost) command to
# exit with a non-zero status, or zero if all commands in the pipeline exit
# successfully.
set -o pipefail

# Set IFS to just newline and tab at the start
#
# http://www.dwheeler.com/essays/filenames-in-shell.html
#
# $DEFAULT_IFS and $SAFER_IFS
#
# $DEFAULT_IFS contains the default $IFS value in case it's needed, such as
# when expanding an array and you want to separate elements by spaces.
# $SAFER_IFS contains the preferred settings for the program, and setting it
# separately makes it easier to switch between the two if needed.
DEFAULT_IFS="${IFS}"
SAFER_IFS=$'\n\t'
IFS="${SAFER_IFS}"

###############################################################################
# Debug
###############################################################################

# _debug()
#
# Usage:
#   _debug printf "Debug info. Variable: %s\\n" "$0"
#
# A simple function for executing a specified command if the `$_USE_DEBUG`
# variable has been set. The command is expected to print a message and
# should typically be either `echo`, `printf`, or `cat`.
__DEBUG_COUNTER=0
_debug() {
  if [[ "${_USE_DEBUG:-"0"}" -eq 1 ]]
  then
    __DEBUG_COUNTER=$((__DEBUG_COUNTER+1))
    # Prefix debug message with "bug (U+1F41B)"
    printf "🐛  %s " "${__DEBUG_COUNTER}"
    "${@}"
    printf "――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――\\n"
  fi
}
# debug()
#
# Usage:
#   debug "Debug info. Variable: $0"
#
# Print the specified message if the `$_USE_DEBUG` variable has been set.
#
# This is a shortcut for the _debug() function that simply echos the message.
debug() {
  _debug echo "${@}"
}

###############################################################################
# Die
###############################################################################

# _die()
#
# Usage:
#   _die printf "Error message. Variable: %s\n" "$0"
#
# A simple function for exiting with an error after executing the specified
# command. The command is expected to print a message and should typically
# be either `echo`, `printf`, or `cat`.
_die() {
  # Prefix die message with "cross mark (U+274C)", often displayed as a red x.
  printf "❌  "
  "${@}" 1>&2
  exit 1
}
# die()
#
# Usage:
#   die "Error message. Variable: $0"
#
# Exit with an error and print the specified message.
#
# This is a shortcut for the _die() function that simply echos the message.
die() {
  _die echo "${@}"
}

###############################################################################
# .bindlerc
###############################################################################

# .dotsrc (backwards compatibility)
#
# If a `.dotsrc` file exists in `$HOME`, source it.
#
# NOTE: This is superceded by .bindlerc if it is present.
#
# TODO: remove this.
if [[ -e "${HOME}/.dotsrc" ]]
then
  BINDLERC="${HOME}/.dotsrc"
fi

# .bindlerc
#
# If a `.bindlerc` file exists in `$HOME`, source it.
if [[ -e "${HOME}/.bindlerc" ]]
then
  BINDLERC="${HOME}/.bindlerc"
fi

if [[ -n "${BINDLERC:-}" ]]
then
  # ShellCheck SC1090
  #
  # ShellCheck is not able to include sourced files from paths that are
  # determined at runtime. The file will not be read, potentially resulting in
  # warnings about unassigned variables and similar. Use a Directive to point
  # ShellCheck to a fixed location it can read instead.
  #
  # https://github.com/koalaman/shellcheck/wiki/SC1090
  #
  # shellcheck source=~/.bindlerc
  source "${BINDLERC:-}"
fi

###############################################################################
# Globals
###############################################################################

_BINDLE_VERSION="7.0.0-alpha.0"

# $DEFAULT_COMMAND
#
# The command to be run by default, when no command name is specified. If the
# environment has an existing $DEFAULT_COMMAND set, then that value is used.
DEFAULT_COMMAND="${DEFAULT_COMMAND:-help}"

###############################################################################
# Options
###############################################################################

# Get raw options for any commands that expect them.
_RAW_OPTIONS="$*"

# Steps:
#
# 1. set expected short options in `optstring` at beginning of the "Normalize
#    Options" section,
# 2. parse options in while loop in the "Parse Options" section.

# Normalize Options ###########################################################

# Source:
#   https://github.com/e36freak/templates/blob/master/options

# The first loop, even though it uses 'optstring', will NOT check if an
# option that takes a required argument has the argument provided. That must
# be done within the second loop and case statement, yourself. Its purpose
# is solely to determine that -oARG is split into -o ARG, and not -o -A -R -G.

# Set short options -----------------------------------------------------------

# option string, for short options.
#
# Very much like getopts, expected short options should be appended to the
# string here. Any option followed by a ':' takes a required argument.
#
# In this example, `-x` and `-h` are regular short options, while `o` is
# assumed to have an argument and will be split if joined with the string,
# meaning `-oARG` would be split to `-o ARG`.
optstring=h

# Normalize -------------------------------------------------------------------

# iterate over options, breaking -ab into -a -b and --foo=bar into --foo bar
# also turns -- into --endopts to avoid issues with things like '-o-', the '-'
# should not indicate the end of options, but be an invalid option (or the
# argument to the option, such as wget -qO-)
unset options
# while the number of arguments is greater than 0
while ((${#}))
do
  case ${1} in
    # if option is of type -ab
    -[!-]?*)
      # loop over each character starting with the second
      for ((i=1; i<${#1}; i++))
      do
        # extract 1 character from position 'i'
        c=${1:i:1}
        # add current char to options
        options+=("-${c}")

        # if option takes a required argument, and it's not the last char
        # make the rest of the string its argument
        if [[ ${optstring} = *"${c}:"* && ${1:i+1} ]]
        then
          options+=("${1:i+1}")
          break
        fi
      done
      ;;
    # if option is of type --foo=bar, split on first '='
    --?*=*)
      options+=("${1%%=*}" "${1#*=}")
      ;;
    # end of options, stop breaking them up
    --)
      options+=(--endopts)
      shift
      options+=("${@}")
      break
      ;;
    # otherwise, nothing special
    *)
      options+=("${1}")
      ;;
  esac

  shift
done
# set new positional parameters to altered options. Set default to blank.
set -- "${options[@]:-}"
unset options

# Parse Options ###############################################################

# Initialize $_COMMAND_ARGV array
#
# This array contains all of the arguments that get passed along to each
# command. This is essentially the same as the program arguments, minus those
# that have been filtered out in the program option parsing loop. This array
# is initialized with $0, which is the program's name.
_COMMAND_ARGV=("${0}")
# Initialize `$_CMD` and `$_USE_DEBUG`, which can continue to be blank
# depending on what the program needs.
_CMD=""
_USE_DEBUG=0

while [ ${#} -gt 0 ]
do
  opt="${1}"
  shift
  case "${opt}" in
    -h|--help)
      _CMD="help"
      ;;
    --version)
      _CMD="version"
      ;;
    --debug)
      _USE_DEBUG=1
      ;;
    *)
      # The first argument encountered is assumed to be the
      # command name, and all subsequent arguments are set as command
      # arguments.
      if [[ -n ${_CMD} ]]
      then
        _COMMAND_ARGV+=("${opt}")
      else
        _CMD=${opt}
      fi
      ;;
  esac
done

# Set $_COMMAND_PARAMETERS to $_COMMAND_ARGV, minus the initial element, $0. This
# provides an array that is equivalent to $* and $@ within each command
# function, though the array is zero-indexed, which could lead to confusion.
#
# Use `unset` to remove the first element rather than slicing (e.g.,
# `_COMMAND_PARAMETERS=("${_COMMAND_ARGV[@]:1}")`) because under bash 3.2 the
# resulting slice is treated as a quoted string and doesn't easily get coaxed
# into a new array.
_COMMAND_PARAMETERS=(${_COMMAND_ARGV[*]})
unset "_COMMAND_PARAMETERS[0]"

_debug printf \
  "\${_CMD}: %s\\n" \
  "${_CMD}"
_debug printf \
  "\${_RAW_OPTIONS} (one per line):\\n%s\\n" \
  "${_RAW_OPTIONS}"
_debug printf \
  "\${_COMMAND_ARGV[*]}: %s\\n" \
  "${_COMMAND_ARGV[*]}"
_debug printf \
  "\${_COMMAND_PARAMETERS[*]:-}: %s\\n" \
  "${_COMMAND_PARAMETERS[*]:-}"

###############################################################################
# Environment
###############################################################################

# $_ME
#
# Set to the program's basename.
_ME=$(basename "${0}")

_debug printf "\${_ME}: %s\\n" "${_ME}"

# $_HOME_DIR
#
# The user's home directory.
if [[ -z "${_HOME_DIR:-}" ]]
then
  _HOME_DIR="${HOME}"
fi

_debug printf "\${_HOME_DIR}: %s\\n" "${_HOME_DIR}"

# $BINDLEPATH
#
# The path to the git-tracked directory containing the bindle-structured
# configuration project.
#
# Set `$BINDLEPATH` if not already set.
if [[ -z "${BINDLEPATH:-}" ]]
then
  BINDLEPATH="${_HOME_DIR}/.bindle"
fi

# _validate_bindlepath_target()
#
# Usage:
#  _validate_bindlepath_target
#
# Description:
#   Check for the presence of a directory at the location specified in
#   $BINDLEPATH. Subcommands that do not require a valid $BINDLEPATH target
#   are exempt from this validation.
_validate_bindlepath_target() {
  if [[ "${_CMD}" == "help"     ]] ||
     [[ "${_CMD}" == "init"     ]] ||
     [[ "${_CMD}" == "version"  ]] ||
     [[ -z "${_CMD}" ]]
  then
    return 0
  fi
  if [[ ! -e "${BINDLEPATH}" ]]
  then
    _die printf "\${BINDLEPATH} (%s) does not exist.\\n" "${BINDLEPATH}"
  fi
  if [[ ! -d "${BINDLEPATH}" ]]
  then
    _die printf "\${BINDLEPATH} (%s) is not a directory.\\n" "${BINDLEPATH}"
  fi
}
_validate_bindlepath_target

# $_BINDLE_HOME_DIR
#
# The directory containing the track files.
_BINDLE_HOME_DIR="${BINDLEPATH}/home"

_debug printf "\${_BINDLE_HOME_DIR}: %s\\n" "${_BINDLE_HOME_DIR}"

# $_GIT_BIN
#
# Must perform git operations via $_GIT_BIN to avoid calling the `bindle git`
# command.
_GIT_BIN="$(which git)"
if [[ -z "${_GIT_BIN}" ]]
then
  _die printf "\
The \`git\` executable can not be found. Since \`${_ME}\` depends on git, \
please install git and make sure it has been added to your \$PATH.\\n"
fi

# Set $EDITOR to blank if it's unbound in order to avoid unrelated errors.
#
# There are cases where this can be blank, such as when a shell environment
# is only partially loaded. The only command that currently uses this
# directly handles the blank case by outputting an error, but nothing else
# should be directly impacted by the blank case.
if [[ -z "${EDITOR:-}" ]]
then
  EDITOR=
fi

###############################################################################
# Load Commands
###############################################################################

# Initialize $_DEFINED_COMMANDS array.
_DEFINED_COMMANDS=()

# _load_commands()
#
# Usage:
#   _load_commands
#
# Loads all of the commands sourced in the environment.
_load_commands() {

  _debug printf "_load_commands(): entering...\\n"
  _debug printf "_load_commands() declare -F:\\n%s\\n" "$(declare -F)"

  # declare is a bash built-in shell function that, when called with the '-F'
  # option, displays all of the functions with the format
  # `declare -f function_name`. These are then assigned as elements in the
  # $function_list array.
  local _function_list=($(declare -F))

  for __name in "${_function_list[@]}"
  do
    # Each element has the format `declare -f function_name`, so set the name
    # to only the 'function_name' part of the string.
    local _function_name
    _function_name=$(printf "%s" "${__name}" | awk '{ print $3 }')

    _debug printf \
      "_load_commands() \${_function_name}: %s\\n" \
      "${_function_name}"

    # Add the function name to the $_DEFINED_COMMANDS array unless it starts
    # with an underscore or is one of the desc(), debug(), or die() functions,
    # since these are treated as having 'private' visibility.
    if ! ( [[ "${_function_name}" =~ ^_(.*)  ]] || \
           [[ "${_function_name}" == "desc"  ]] || \
           [[ "${_function_name}" == "debug" ]] || \
           [[ "${_function_name}" == "die"   ]]
    )
    then
      _DEFINED_COMMANDS+=("${_function_name}")
    fi
  done

  _debug printf \
    "commands() \${_DEFINED_COMMANDS[*]:-}:\\n%s\\n" \
    "${_DEFINED_COMMANDS[*]:-}"
}

###############################################################################
# Main
###############################################################################

# _main()
#
# Usage:
#   _main
#
# The primary function for starting the program.
#
# NOTE: must be called at end of program after all commands have been defined.
_main() {
  _debug printf "main(): entering...\\n"
  _debug printf "main() \${_CMD} (upon entering): %s\\n" "${_CMD}"

  # If $_CMD is blank, then set to `$DEFAULT_COMMAND`
  if [[ -z ${_CMD} ]]
  then
    _CMD="${DEFAULT_COMMAND}"
  fi

  # Load all of the commands.
  _load_commands

  # If the command is defined, run it, otherwise return an error.
  if _contains "${_CMD}" "${_DEFINED_COMMANDS[*]:-}"
  then
    # Pass all comment arguments to the program except for the first ($0).
    ${_CMD} "${_COMMAND_PARAMETERS[@]:-}"
  else
    _die printf "Unknown command: %s\\n" "${_CMD}"
  fi
}

###############################################################################
# Utility Functions
###############################################################################

# _each_file()
#
# Usage:
#   _each_file directory function
#
# Iterate over the files in the specified directory and execute the specified
# function.
_each_file() {
  local _search_files=("${1}"/.*)
  local _callback_function="${2}"

  _debug printf \
    "_each_file() \${#_search_files[@]}: %s\\n" \
    "${#_search_files[@]}"

  for __file_path in "${_search_files[@]}"
  do
    local _file_basename
    _file_basename="$(basename "${__file_path}")"

    local _tracked_file_path
    _tracked_file_path="${_BINDLE_HOME_DIR}/${_file_basename}"

    local _original_file_path
    _original_file_path="${_HOME_DIR}/${_file_basename}"

    if ! ( [[ "${_file_basename}" =~ ^\.?\.$     ]] || \
           [[ "${_file_basename}" == ".DS_Store" ]]
    )
    then
      ${_callback_function} \
        "${__file_path}" \
        "${_file_basename}" \
        "${_tracked_file_path}" \
        "${_original_file_path}"
    fi
  done
}

# _each_tracked_file()
#
# Usage:
#   _each_tracked_file function
#
# Iterate over the files in the tracked directory and execute the specified
# function.
_each_tracked_file() {
  _each_file "${_BINDLE_HOME_DIR}" "${1}"
}

# _each_original_file()
#
# Usage:
#   _each_original_file function
#
# Iterate over the files in the original directory and execute the specified
# function.
_each_original_file() {
  _each_file "${_HOME_DIR}" "${1}"
}

# _function_exists()
#
# Usage:
#   _function_exists "possible_function_name"
#
# Returns:
#   0  If a function with the given name is defined in the current environment.
#   1  If not.
#
# Other implementations, some with better performance:
# http://stackoverflow.com/q/85880
_function_exists() {
  [ "$(type -t "${1}")" == 'function' ]
}

# _command_exists()
#
# Usage:
#   _command_exists "possible_command_name"
#
# Returns:
#   0  If a command with the given name is defined in the current environment.
#   1  If not.
#
# Information on why `hash` is used here:
# http://stackoverflow.com/a/677212
_command_exists() {
  hash "${1}" 2>/dev/null
}

# _contains()
#
# Usage:
#   _contains "$item" "${list[*]}"
#
# Returns:
#   0  If the item is included in the list.
#   1  If not.
_contains() {
  local _test_list=(${*:2})
  for __test_element in "${_test_list[@]:-}"
  do
    _debug printf "_contains() \${__test_element}: %s\\n" "${__test_element}"
    if [[ "${__test_element}" == "${1}" ]]
    then
      _debug printf "_contains() match: %s\\n" "${1}"
      return 0
    fi
  done
  return 1
}

# _join()
#
# Usage:
#   _join "," a b c
#   _join "${an_array[@]}"
#
# Returns:
#   The list or array of items joined into a string with elements divided by
#   the optional separator if one is provided.
_join() {
  local _separator
  local _target_array
  local _dirty
  local _clean
  _separator="${1}"
  _target_array=(${@:2})
  _dirty="$(printf "${_separator}%s"  "${_target_array[@]}")"
  _clean="${_dirty:${#_separator}}"
  printf "%s" "${_clean}"
}

# _command_argv_includes()
#
# Usage:
#   _command_argv_includes "an_argument"
#
# Returns:
#   0  If the argument is included in `$_COMMAND_ARGV`, the program's command
#      argument list.
#   1  If not.
#
# This is a shortcut for simple cases where a command wants to check for the
# presence of options quickly without parsing the options again.
_command_argv_includes() {
  _contains "${1}" "${_COMMAND_ARGV[*]}"
}

# _blank()
#
# Usage:
#   _blank "$an_argument"
#
# Returns:
#   0  If the argument is not present or null.
#   1  If the argument is present and not null.
_blank() {
  [[ -z "${1:-}" ]]
}

# _present()
#
# Usage:
#   _present "$an_argument"
#
# Returns:
#   0  If the argument is present and not null.
#   1  If the argument is not present or null.
_present() {
  [[ -n "${1:-}" ]]
}

# _interactive_input()
#
# Usage:
#   _interactive_input
#
# Returns:
#   0  If the current input is interactive (eg, a shell).
#   1  If the current input is stdin / piped input.
_interactive_input() {
  [[ -t 0 ]]
}

# _piped_input()
#
# Usage:
#   _piped_input
#
# Returns:
#   0  If the current input is stdin / piped input.
#   1  If the current input is interactive (eg, a shell).
_piped_input() {
  ! _interactive_input
}

# _highlight()
#
# Usage:
#   _highlight <string>
#
# Description:
#   Use `tput` to highlight the given string.
_highlight() {
  local _input="${1:-}"
  if [[ -z "${_input}" ]]
  then
    _die printf "Usage: _highlight <string>"
  fi
  printf "$(tput setaf 3)%s$(tput sgr0)\\n" "${_input}"
}

###############################################################################
# desc
###############################################################################

# desc()
#
# Usage:
#   desc <name> <description>
#   desc --get <name>
#
# Options:
#   --get  Print the description for <name> if one has been set.
#
# Examples:
# ```
#   desc "list" <<HEREDOC
# Usage:
#   ${_ME} list
#
# Description:
#   List items.
# HEREDOC
#
# desc --get "list"
# ```
#
# Set or print a description for a specified command or function <name>. The
# <description> text can be passed as the second argument or as standard input.
#
# To make the <description> text available to other functions, `desc()` assigns
# the text to a variable with the format `$___desc_<name>`.
#
# When the `--get` option is used, the description for <name> is printed, if
# one has been set.
#
# NOTE:
#
# The `read` form of assignment is used for a balance of ease of
# implementation and simplicity. There is an alternative assignment form
# that could be used here:
#
# var="$(cat <<'HEREDOC'
# some message
# HEREDOC
# )
#
# However, this form appears to require trailing space after backslases to
# preserve newlines, which is unexpected. Using `read` simply requires
# escaping backslashes, which is more common.
desc() {
  set +e
  [[ -z "${1:-}" ]] && _die printf "desc(): No command name specified.\\n"

  if [[ "${1}" == "--get" ]]
  then # get ------------------------------------------------------------------
    [[ -z "${2:-}" ]] && _die printf "desc(): No command name specified.\\n"

    local _name="${2:-}"
    local _desc_var="___desc_${_name}"

    if [[ -n "${!_desc_var:-}" ]]
    then
      printf "%s\\n" "${!_desc_var}"
    else
      printf "No additional information for \`%s\`\\n" "${_name}"
    fi
  else # set ------------------------------------------------------------------
    if [[ -n "${2:-}" ]]
    then # argument is present
      read -r -d '' "___desc_${1}" <<HEREDOC
${2}
HEREDOC

      _debug printf "desc() set with argument: \${___desc_%s}\\n" "${1}"
    else # no argument is present, so assume piped input
      read -r -d '' "___desc_${1}"

      _debug printf "desc() set with pipe: \${___desc_%s}\\n" "${1}"
    fi
  fi
  set -e
}

###############################################################################
# Default Commands
###############################################################################

# Version #####################################################################

desc "version" <<HEREDOC
Usage:
  ${_ME} ( version | --version )

Description:
  Display the current program version.

  To save you the trouble, the current version is ${_BINDLE_VERSION}
HEREDOC
version() {
  printf "%s\\n" "${_BINDLE_VERSION}"
}

# Help ########################################################################

desc "help" <<HEREDOC
Usage:
  ${_ME} help [<command>]

Description:
  Display help information for ${_ME} or a specified command.
HEREDOC
help() {
  if [[ ${#_COMMAND_ARGV[@]} = 1 ]]
  then
    cat <<HEREDOC

 _____  ___  _____  _____  ____   _____
/  _  \\/___\\/  _  \\|  _  \\/  _/  /   __\\
|  _  <|   ||  |  ||  |  ||  |---|   __|
\\_____/\\___/\\__|__/|_____/\\_____/\\_____/

A configuration management tool for your personal unix-like computer.

Version: ${_BINDLE_VERSION}

Usage:
  ${_ME} <command> [<arguments>]
  ${_ME} -h | --help
  ${_ME} --version

Options:
  --debug    Print debug information.
  -h --help  Display this help information.
  --version  Display version information.

Help:
  ${_ME} help [<command>]

$(commands)
HEREDOC
  else
    desc --get "${1}"
  fi
}

# Command List ################################################################

desc "commands" <<HEREDOC
Usage:
  ${_ME} commands [--raw]

Options:
  --raw  Display the command list without formatting.

Description:
  Display the list of available commands.
HEREDOC
commands() {
  if _command_argv_includes "--raw"
  then
    printf "%s\\n" "${_DEFINED_COMMANDS[@]:-}"
  else
    printf "Available commands:\\n"
    printf "  %s\\n" "${_DEFINED_COMMANDS[@]:-}"
  fi
}

###############################################################################
# Commands
# ========.....................................................................
#
# Example command group structure:
#
# desc example ""         - Optional. A short description for the command.
# _example_item() { : }   - Optional. A child function to be run for each item.
# example() { : }         - The command called by the user.
#
#
# desc example <<HEREDOC
#   Usage:
#     $_ME example
#
#   Description:
#     List files.
#
#     For usage formatting conventions see:
#     - http://docopt.org/
#     - http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html
# HEREDOC
# _example() {
#   echo $f
#   echo $tracked_file
#   echo $filename
#   echo $original_file
# }
# example() {
#   echo ">> Listing each dotfile in repository"
#   _each_tracked_file _example
#   echo ">> Listing each dotfile in HOME"
#   _each_original_file _example
# }

###############################################################################

# init ########################################################################

# ------------------------------------------------------------------------ init

desc "init" <<HEREDOC
Usage:
  ${_ME} init [<source_repository>] [<bindlepath>] [--initialize-submodules] \
[--skip-bindlerc]

Options:
  --initialize-submodules  Initialize repository submodules when used with a
                           source_repository argument.
  --skip-bindlerc          Don't generate a bindlerc file.

Description:
  Create initial repository file structure.

  When provided with a URL as the first argument or a second argument the git
  repository at that URL is cloned and used as the tracking repository.

  When provided with an absolute path as the lone argument or second argument
  after a repository URL, the initial repository is created at the specified
  path and a configuration file is created at \$HOME/.bindlerc with that
  location set as the \$BINDLEPATH.
HEREDOC
# _init_with_source()
#
# Clone a specified URL to a specified path.
#
# called by: init()
_init_with_source() {
  _debug printf "_init_with_source() \${1}: %s\\n" "${1}"
  _debug printf "_init_with_source() \${2}: %s\\n" "${2}"

  if [[ -z "${1}" ]]
  then
    _die printf "Repository directory not specified.\\n"
  elif [[ -z "${2}" ]]
  then
    _die printf "Source URL not specified.\\n"
  else
    "${_GIT_BIN}" clone "${2}" "${1}"
  fi

  if _command_argv_includes "--initialize-submodules"
  then
    cd "${1}"
    "${_GIT_BIN}" submodule init
    "${_GIT_BIN}" submodule update --init --recursive
  fi
}
# _init_bindlerc()
#
# Create a file at $HOME/.bindlerc for configuration settings.
#
# called by: init()
_init_bindlerc() {
  _command_argv_includes "--skip-bindlerc" && return 0
  if [[ -n "${1}" ]]
  then
    printf ">> Adding ~/.bindlerc configuration file.\\n"
    printf "\
# .bindlerc
#
# Configuration file for Bindle
#
# https://github.com/alphabetum/bindle

# Set bindle directory
export BINDLEPATH=\"%s\"
" "${1}" >> "${HOME}/.bindlerc"
  else
    printf "Repository location not specified.\\n"
  fi
}
# _init_directory_structure()
#
# Create an initial directory structure at $BINDLEPATH
#
# called by: init()
_init_directory_structure() {
  if [[ -n "${1}" ]]
  then
    mkdir "${1}"
    mkdir "${1}/bin"
    touch "${1}/bin/.gitkeep"
    mkdir "${1}/home"
    # No .gitkeep since all dotfiles in this directory are linked and tracked.
    mkdir "${1}/local"
    touch "${1}/local/.gitkeep"
    mkdir "${1}/scripts"
    mkdir "${1}/scripts/bootstrap"
    touch "${1}/scripts/bootstrap/.gitkeep"
    mkdir "${1}/scripts/install"
    touch "${1}/scripts/install/.gitkeep"
    mkdir "${1}/scripts/configure"
    touch "${1}/scripts/configure/.gitkeep"
    mkdir "${1}/scripts/customize"
    touch "${1}/scripts/customize/.gitkeep"
  else
    printf "Repository directory not specified.\\n"
  fi
}
# _init_gitignore()
#
# Add the default .gitignore to $BINDLEPATH/.gitignore
#
# called by: init()
_init_gitignore() {
  if [[ -n "${1}" ]]
  then
    printf "\
# Ignore the local directory, but track .gitkeep so it's included in the repo.
/local/*
!/local/.gitkeep

# Only track .ssh/config. Everything else in .ssh is private
/home/.ssh/*
!/home/.ssh/config
" >> "${1}/.gitignore"
  else
    printf "Repository directory not specified.\\n"
  fi
}
# _init_git_repository()
#
# Initialize the git repository at $BINDLEPATH
#
# called by: init()
_init_git_repository() {
  if [[ -n "${1}" ]]
  then
    cd "${1}"
    "${_GIT_BIN}" init
  else
    printf "Repository directory not specified.\\n"
  fi
}
# _init_post_message()
#
# Print information about what just happened and some next steps.
#
# called by: init()
_init_post_message() {
  if [[ -n "${1}" ]]
  then
    printf "\
 _____  ___  _____  _____  ____   _____
/  _  \\/___\\/  _  \\|  _  \\/  _/  /   __\\
|  _  <|   ||  |  ||  |  ||  |---|   __|
\\_____/\\___/\\__|__/|_____/\\_____/\\_____/

Your bindle git repo has been initialized at the following location:

%s
" "${1}"
  else
    printf "Repository directory not specified.\\n"
  fi
}
# init()
#
# Initialize a new repository.
init() {
  # Initialize variables
  #
  # $init_souce: will be set to a source git repository URL if available.
  local _init_source
  # A URL-matching regex to check arguments for a source git repository.
  local _git_regex='(https?|git|ssh|file)://[-A-Za-z0-9\+&@#/%?=~_|!:,.;]*[-A-Za-z0-9\+&@#/%=~_|]'

  # Handle arguments.
  #
  # Expected behavior:
  #   init [<source_repository>] [<bindlepath>]
  if [[ -n "${1}" ]]
  then
    if [[ "${1}" =~ ${_git_regex} ]]
    then
      _init_source="${1}"
      if [[ -n "${2}" ]]
      then
        BINDLEPATH="${2}"
        _init_bindlerc "${BINDLEPATH}"
      fi
    else
      BINDLEPATH="${1}"
      _init_bindlerc "${BINDLEPATH}"
    fi
  fi
  _debug printf "init() \${BINDLEPATH}: %s\\n" "${BINDLEPATH}"
  _debug printf "init() \${_init_source}: %s\\n" "${_init_source}"

  # Initialize either from source or with fresh directory structure.
  if [[ ! -e "${BINDLEPATH}" ]]
  then
    if [[ -n "${_init_source}" ]]
    then
      _init_with_source "${BINDLEPATH}" "${_init_source}"
    else
      _init_directory_structure "${BINDLEPATH}"
      _init_gitignore "${BINDLEPATH}"
      _init_git_repository "${BINDLEPATH}"
    fi
    _init_post_message "${BINDLEPATH}"
  else
    _die printf "\
A file or directory already exists at the dotfile repository path:
%s\\n" "${BINDLEPATH}"
  fi
}

# git #########################################################################

# ---------------------------------------------------------------------- commit

desc "commit" <<HEREDOC
Usage:
  ${_ME} commit [<message>]

Description:
  Commit the current changes to git. If a message is provided, it will be used
  as the commit message. Otherwise, git will open your default editor.
HEREDOC
commit() {
  cd "${BINDLEPATH}"
  if [[ -n "${1}" ]]
  then
    "${_GIT_BIN}" add .
    "${_GIT_BIN}" commit -a -m "${1}"
  else
    "${_GIT_BIN}" add .
    "${_GIT_BIN}" commit -a
  fi
}

# ------------------------------------------------------------------------- git

desc "git" <<HEREDOC
Usage:
  ${_ME} git command [--options] [<arguments>]

Description:
  Run a git command within the \$BINDLEPATH directory.
HEREDOC
git() {
  # Perform git operations in the $BINDLEPATH directory.
  cd "${BINDLEPATH}"

  # Set $IFS to default for better argument handling.
  IFS="${DEFAULT_IFS}"

  # Use raw options to get the option string, with some parts stripped.
  local _git_options
  _git_options=($(printf "%s" "${_RAW_OPTIONS}" | \
    tr '\\n' ' ' | \
    sed -e 's/--debug//' | \
    sed -e 's/^git //'     \
  ))

  # call the environment's git with the git options passed as an array.
  "${_GIT_BIN}" "${_git_options[@]}"
}

# ------------------------------------------------------------------------ pull

desc "pull" <<HEREDOC
Usage:
  ${_ME} pull

Description:
  Pull latest changes from the remote repository.
HEREDOC
pull() {
  cd "${BINDLEPATH}"
  "${_GIT_BIN}" pull
  _debug printf "%s pull\\n" "${_GIT_BIN}"
}

# ------------------------------------------------------------------------ push

desc "push" <<HEREDOC
Usage:
  ${_ME} push

Description:
  Push local commits to the remote repository.
HEREDOC
push() {
  cd "${BINDLEPATH}"
  "${_GIT_BIN}" push
  _debug printf "%s push\\n" "${_GIT_BIN}"
}

# ------------------------------------------------------------------ submodules

desc "submodules" <<HEREDOC
Usage:
  ${_ME} submodules ( sync | update )

Subcommands:
  sync    Sync all submodules with the current head commit. This usually be
          should be performed after a \`${_ME} pull\`. Equivalent git command:
            git submodule update --recursive --init
  update  Update all first-level submodules to the latest commit in each
          submodule's origin repository. Equivalent git command:
            git submodule update --init --remote
HEREDOC
submodules() {
  cd "${BINDLEPATH}"
  case "${1}" in
    sync)
      "${_GIT_BIN}" submodule update --init --recursive
      ;;
    update)
      "${_GIT_BIN}" submodule update --init --remote
      ;;
    *)
      _die printf "Unrecognized subcommand: submodules %s\\n" "${1}"
      ;;
  esac
}

# ------------------------------------------------------------------------ sync

desc "sync" <<HEREDOC
Usage:
  ${_ME} sync

Description:
  Pull latest changes from the remote repository and sync submodules.
HEREDOC
sync() {
  pull && submodules sync
}

# Scripts #####################################################################

# ------------------------------------------------------------------------- run

desc "run" <<HEREDOC
Usage:
  ${_ME} run ( list | <script_name> )

Description:
  Run and list scripts.

  Scripts can be added to:
    ${BINDLEPATH}/scripts/
HEREDOC
run() {
  local _script_directory_name="scripts"
  if [[ -d "${BINDLEPATH}/script" ]] && [[ ! -d "${BINDLEPATH}/scripts" ]]
  then
    _script_directory_name="script"
  fi

  local _script_identifier="${1:-}"
  local _script_directory_path="${BINDLEPATH}/${_script_directory_name}"
  local _script_path="${_script_directory_path}/${_script_identifier}"

  if [[ "${_script_identifier}" == "list" ]]
  then
    local _script_subdirectory_path="${2:-}"
    if [[ -n "${_script_subdirectory_path}" ]]
    then
      _script_directory_path="${_script_directory_path}/${_script_subdirectory_path}"
    fi

    _debug printf \
      "run(): \${_script_directory_path}: %s\\n" \
      "${_script_directory_path}"

    for __file_path in $(find "${_script_directory_path}" -type f -follow -print)
    do
      if [[ -f "${__file_path}" ]] && [[ ! "${__file_path}" =~ .DS_Store|.md ]]
      then
        printf "%s\\n" "${__file_path#${_script_directory_path}/}"
      fi
    done
  elif [[ -f "${_script_path}" ]]
  then
    local _script_arguments=(${@:2})
    printf ">> Running %s\\n" "$(basename "${_script_path}")"
    "${_script_path}" "${_script_arguments[@]:-}"
  elif [[ -d "${_script_path}" ]]
  then
    if [[ -n "${1:-}" ]]
    then
      _highlight "$(
        printf "%s/%s:\\n" \
          "${_script_directory_name}" \
          "${1:-}"
        )"
      run list "${1:-}"
    else
      _highlight "$(printf "%s:\\n" "${_script_directory_name}")"
      run list
    fi
  else
    _die printf "'%s' not found.\\n" "${_script_path}"
  fi
}

# Dotfiles ####################################################################

# ------------------------------------------------------------------------- add

desc "add" <<HEREDOC
Usage:
  ${_ME} add <filename> [--force]

Description:
  \`add\` is an alias for \`track\`. For more information, run:
    \`bindle help track\`
HEREDOC
add() {
  track "$@"
}

# -------------------------------------------------------------------- dotfiles

desc "dotfiles" <<HEREDOC
Usage:
  ${_ME} dotfiles

Description:
  List all dotfiles. Alias for \`$_ME status\`.
HEREDOC
dotfiles() {
  status "$@"
}

# ------------------------------------------------------------------------ link

desc "link" <<HEREDOC
Usage:
  ${_ME} link [<filename>] [--overwrite [--with-backup]]

Options:
  --overwrite    Overwrite any files that exist in the directory where links
                 are being created, meaning that any conflicting files will be
                 deleted and links to the corresponding repository file will
                 be created.
  --with-backup  When used in combination with --overwrite, any overwritten
                 files are first renamed with a '.bak' extension. If a file
                 with the same name plus '.bak' extension already exists,
                 nothing is done to this file and no link is created.

Description:
  Create a link in \$HOME that references the corresponding item in the
  tracked directory.

  By default, the command links all files that exist in the tracked directory.
  If a filename is passed to the link command, then it only acts on that file.
HEREDOC
link() {
  _link_item() {
    local _file_path="${1:-}"
    local _file_basename="${2:-}"
    local _tracked_file_path="${3:-}"
    local _original_file_path="${4:-}"

    if [[ -e "${_original_file_path}" ]]
    then
      if ((_OVERWRITE))
      then
        if ((_WITH_BACKUP))
        then
          if [[ -e "${_original_file_path}.bak" ]]
          then
            printf \
              "Exists with .bak: %s, %s\\n" \
              "${_file_basename}" \
              "${_file_basename}.bak"
            return 0
          else
            mv "${_original_file_path}" "${_original_file_path}.bak"
          fi
        else
          rm "${_original_file_path}"
        fi
      else
        printf "Exists: %s\\n" "${_file_basename}"
        return 0
      fi
    fi
    printf "Linking %s => %s\\n" \
      "${_tracked_file_path}" \
      "${_original_file_path}"
    ln -s "${_tracked_file_path}" "${_original_file_path}"
  }

  export _OVERWRITE=0
  export _WITH_BACKUP=0
  local _arguments=()

  for __arg in "${_COMMAND_ARGV[@]:-}"
  do
    case ${__arg} in
      --overwrite)    _OVERWRITE=1;;
      --with-backup)  _WITH_BACKUP=1;;
      *)              _arguments+=(${__arg});;
    esac
  done

  if [[ -n "${_arguments[1]:-}" ]]
  then
    local _file_path
    _file_path="${_BINDLE_HOME_DIR}/${_arguments[1]}"

    local _file_basename
    _file_basename="$(basename "${_arguments[1]}")"

    local _tracked_file_path
    _tracked_file_path="${_BINDLE_HOME_DIR}/${_file_basename}"

    local _original_file_path
    _original_file_path="${_HOME_DIR}/${_file_basename}"

    if [[ -e "${_tracked_file_path}" ]]
    then
      _debug printf "link(): link with existing tracked file.\\n"

      _link_item \
        "${_file_path}" \
        "${_file_basename}" \
        "${_tracked_file_path}" \
        "${_original_file_path}"
    else
      _die printf "Tracked file not found: %s\\n" "${_tracked_file_path}"
    fi
  else
    _debug printf "link(): link all tracked files.\\n"

    _each_tracked_file "_link_item"
  fi
}

# ------------------------------------------------------------------------ list

desc "list" <<HEREDOC
Usage:
  ${_ME} list [tracked | untracked] [<search string>]

Description:
  List all files in \$HOME.

  If 'tracked' or 'untracked' as passed as arguments to 'list', then only the
  files with those statuses are listed. When provided with a seach string, all
  matching filenames will be printed.
HEREDOC
list() {
  _list_item() {
    local _file_path="${1:-}"
    local _file_basename="${2:-}"
    local _tracked_file_path="${3:-}"
    local _original_file_path="${4:-}"

    if [[ -L ${_file_path} ]]
    then
      if [[ "$(readlink "${_file_path}")" == "${_tracked_file_path}" ]]
      then
        printf "✅ 🔗  %s\\n" "${_file_basename}"
      else
        printf "  🔗  %s\\n" "${_file_basename}"
      fi
    elif [[ -d ${_file_path} ]]
    then
      printf "  📂  %s\\n" "${_file_basename}"
    elif [[ -e ${_file_path} ]]
    then
      printf "  ⚙️  %s\\n" "${_file_basename}"
    fi
  }

  if [[ "${1}" == "tracked" ]] || [[ "${1}" == "untracked" ]]
  then
    if _blank "${2:-}"
    then
      "${1}"
    else
      "${1}" | grep "${2:-}"
    fi
  elif [[ -n "${1:-}" ]]
  then
    _each_original_file "_list_item" | grep "${1:-}"
  else
    _each_original_file "_list_item"
  fi
}

# ---------------------------------------------------------------------- rename

desc "rename" <<HEREDOC
Usage:
  ${_ME} rename <old_filename> <new_filename>

Decription:
  Rename a tracked file and its corresponding link in \$HOME.
HEREDOC
rename() {
  local _old_file="${_BINDLE_HOME_DIR}/${1}"
  _debug printf "rename() \${_old_file}: %s\\n" "${_old_file}"

  local _new_file="${_BINDLE_HOME_DIR}/${2}"
  _debug printf "rename() \${_new_file}: %s\\n" "${_new_file}"

  if [[ -z "${1}" ]]
  then
    printf "Filename not provided.\\n"
  elif [[ -z "${2}" ]]
  then
    printf "New name not provided.\\n"
  elif [[ ! -e "${_old_file}" ]]
  then
    printf "File not found.\\n"
  elif [[ -e "${_new_file}" ]]
  then
    printf "A file already exists with the new filename.\\n"
  else
    "${_ME}" unlink "${1}"
    _debug printf "unlink %s\\n" "${1}"

    mv "${_old_file}" "${_new_file}"
    _debug printf "mv %s %s\\n" "${_old_file}" "${_new_file}"

    "${_ME}" link "${2}"
    _debug printf "link %s\\n" "${2}"
  fi
}

# --------------------------------------------------------------------- restore

desc "restore" <<HEREDOC
Usage:
  ${_ME} restore <filename>

Description:
  \`restore\` is an alias for \`untrack\`. For more information, run:
    \`bindle help untrack\`
HEREDOC
restore() {
  untrack "$@"
}

# --------------------------------------------------------------------- scripts

desc "scripts" <<HEREDOC
Usage:
  ${_ME} scripts

Description:
  List all scripts. Alias for \`$_ME run\`.
HEREDOC
scripts() {
  run "$@"
}

# ---------------------------------------------------------------------- status

desc "status" <<HEREDOC
Usage:
  ${_ME} status

Description:
  List status of files in \$HOME with filenames matching those in
  \$BINDLEPATH/home/.

  Indicators display information about the status of each entry:
    ✅   - Identical, indicating a valid symbolic link to the tracked file
     e  - A file exists, but it's not linked to tracked file
      x - No file exists
HEREDOC
status() {
  _status_item() {
    local _file_path="${1:-}"
    local _file_basename="${2:-}"
    local _tracked_file_path="${3:-}"
    local _original_file_path="${4:-}"

    if ( [[ -L "${_original_file_path}" ]] && \
         [[ "$(readlink "${_original_file_path}")" == "${_file_path}" ]]
    )
    then
      printf "✅   %s\\n" "${_file_basename}"
    elif [[ -e "${_original_file_path}" ]]
    then
      printf " e  %s\\n" "${_file_basename}"
    else
      printf "  x %s\\n" "${_file_basename}"
    fi
  }

  _each_tracked_file "_status_item"
}

# ----------------------------------------------------------------------- track

desc "track" <<HEREDOC
Usage:
  ${_ME} track <filename> [--force]

Options:
  --force  Overwrite files and folders in the repository that have the same
           name as the item(s) being added.

Description:
  Track the specified file, adding it to the repository and adding a link in
  \$HOME to the tracked file.
HEREDOC
track() {
  _debug printf "track() \${1}: %s\\n" "${1}"

  local _force=0
  local _arguments=()

  for __arg in "${_COMMAND_ARGV[@]:-}"
  do
    case ${__arg} in
      --force) _force=1;;
      *) _arguments+=(${__arg});;
    esac
  done


  if [[ -z "${_arguments[1]:-}" ]]
  then
    _die printf "Must specify a valid file or directory name.\\n"
  else
    local _file_basename
    _file_basename="$(basename "${_arguments[1]:-}")"

    local _original_file="${_HOME_DIR}/${_file_basename}"
    _debug printf "track() \${_original_file}: %s\\n" "${_original_file}"

    local _tracked_file="${_BINDLE_HOME_DIR}/${_file_basename}"
    _debug printf "track() \${_tracked_file}: %s\\n" "${_tracked_file}"

    # Because the if / else is complicated, guarding against errors by only
    # proceeding when this variable has been set.
    local _is_safe_to_proceed=0

    if [[ ! -e "${_original_file}" ]]
    then
      _die printf "File or directory does not exist.\\n"
    elif ( \
      [[ "${_file_basename}" == "/"  ]] || \
      [[ "${_file_basename}" == "."  ]] || \
      [[ "${_file_basename}" == ".." ]]
    )
    then
      _die printf "Invalid filename: %s\\n" "${_file_basename}"
    elif [[ -e "${_tracked_file}" ]]
    then
      if ((_force))
      then
        printf "Overwriting %s\\n" "${_tracked_file}"
        while true
        do
          read -r -p "Are you sure you want to proceed? [y/n] " yn
          case ${yn} in
            [Yy]* )
              printf "Removing %s\\n" "${_tracked_file}"
              rm -r "${_tracked_file}"
              break
              ;;
            [Nn]* )
              printf "Exiting...\\n"
              exit
              ;;
            * )
              printf "Please answer yes or no.\\n"
              ;;
          esac
        done
        _is_safe_to_proceed=1
      else
        _die printf "File has already been added.\\n"
      fi
    elif [[ -L "${_original_file}" ]]
    then
      _die printf "Original is already a symlink.\\n"
    else
      _is_safe_to_proceed=1
    fi
    if ((_is_safe_to_proceed))
    then
      mv "${_original_file}" "${_BINDLE_HOME_DIR}"
      printf "Linked: %s => %s\\n" "${_tracked_file}" "${_original_file}"
      ln -s "${_tracked_file}" "${_original_file}"
    fi
  fi
}

# --------------------------------------------------------------------- tracked

desc "tracked" <<HEREDOC
Usage:
  ${_ME} tracked

Description:
  List all tracked dotfiles in \$HOME.
HEREDOC
tracked() {
  _print_tracked_item() {
    local _file_path="${1:-}"
    local _file_basename="${2:-}"
    local _tracked_file_path="${3:-}"

    if ( [[ -L ${_file_path} ]] && \
         [[ "$(readlink "${_file_path}")" == "${_tracked_file_path}" ]]
    )
    then
      printf "✅ 🔗  %s\\n" "${_file_basename}"
    fi
  }

  _each_original_file "_print_tracked_item"
}

# ---------------------------------------------------------------------- unlink

desc "unlink" <<HEREDOC
Usage:
  ${_ME} unlink [<filename>]

Description:
  Remove symlinks in \$HOME.

  By default, the command removes all of the symlinks pointing to items in
  tracked directory. If a filename is passed to the unlink command, then it
  only acts on symlinks to that file.
HEREDOC
unlink() {
  _unlink_item() {
    local _file_path="${1:-}"
    local _file_basename="${2:-}"
    local _tracked_file_path="${3:-}"
    local _original_file_path="${4:-}"

    if ( [[ -L "${_original_file_path}" ]] && \
         [[ "$(readlink "${_original_file_path}")" == "${_file_path}" ]]
    )
    then
      printf "Removing link: %s\\n" "${_original_file_path}"
      rm "${_original_file_path}"
    fi
  }

  if [[ -n "${1}" ]]
  then
    local _file_path
    _file_path="${_BINDLE_HOME_DIR}/${1}"

    local _file_basename
    _file_basename="$(basename "${_file_path}")"

    local _tracked_file_path
    _tracked_file_path="${_BINDLE_HOME_DIR}/${_file_basename}"

    local _original_file_path
    _original_file_path="${_HOME_DIR}/${_file_basename}"

    _unlink_item \
      "${_file_path}" \
      "${_file_basename}" \
      "${_tracked_file_path}" \
      "${_original_file_path}"
  else
    _each_tracked_file "_unlink_item"
  fi
}

# --------------------------------------------------------------------- untrack

desc "untrack" <<HEREDOC
Usage:
  ${_ME} untrack <filename>

Description:
  Unlink the specified file and move it from the tracked location in the
  repository back to original location in \$HOME.
HEREDOC
untrack() {
  _debug printf "untrack() \${1}: %s\\n" "${1}"

  if [[ ${#} = 0 ]]
  then
    _die printf "Must specify a valid file or directory name.\\n"
  else
    local _file_basename
    _file_basename="$(basename "${1}")"

    local _original_file="${_HOME_DIR}/${_file_basename}"
    _debug printf "untrack() \${_original_file}: %s\\n" "${_original_file}"

    local _tracked_file="${_BINDLE_HOME_DIR}/${_file_basename}"
    _debug printf "untrack() \${_tracked_file}: %s\\n" "${_tracked_file}"

    if [[ ! -e "${_tracked_file}" ]]
    then
      printf "File does not exist.\\n"
    elif [[ ! -L "${_original_file}" ]]
    then
      printf "File is not a symlink.\\n"
    else
      rm "${_original_file}"
      mv "${_tracked_file}" "${_original_file}"
      printf "Restored: %s => %s\\n" "${_tracked_file}" "${_original_file}"
    fi
  fi
}

# ------------------------------------------------------------------- untracked

desc "untracked" <<HEREDOC
Usage:
  ${_ME} untracked

Description:
  List all untracked dotfiles in \$HOME.
HEREDOC
untracked() {
  _print_untracked_item() {
    local _file_path="${1:-}"
    local _file_basename="${2:-}"
    local _tracked_file_path="${3:-}"

    if [[ -L ${_file_path} ]]
    then
      if ! ( [[ "$(readlink "${_file_path}")" == "${_tracked_file_path}" ]] )
      then
        printf "  🔗  %s\\n" "${_file_basename}"
      fi
    elif [[ -d ${_file_path} ]]
    then
      printf "  📂  %s\\n" "${_file_basename}"
    elif [[ -e ${_file_path} ]]
    then
      printf "  ⚙️  %s\\n" "${_file_basename}"
    fi
  }

  _each_original_file "_print_untracked_item"
}

# Utilties ####################################################################

# ------------------------------------------------------------------------- dir

desc "dir" <<HEREDOC
Usage:
  ${_ME} dir

Description:
  Print the current value of \$BINDLEPATH
HEREDOC
dir() {
  printf "%s\\n" "${BINDLEPATH}"
}

# ------------------------------------------------------------------------ edit

desc "edit" <<HEREDOC
Usage:
  ${_ME} edit
  ${_ME} edit [<filename>]

Description:
  Open a tracked file or, when no filename is specified, the entire tracked
  repository in you \$EDITOR, currently set to '${EDITOR}'.
HEREDOC
edit() {
  [[ -z "${EDITOR}" ]] && _die printf "\$EDITOR is not set.\\n"
  if [[ -n "${1:-}" ]]
  then
    local _tracked_file="${_BINDLE_HOME_DIR}/${1}"
    ${EDITOR} "${_tracked_file}"
  else
    ${EDITOR} "${BINDLEPATH}"
  fi
}

###############################################################################
# Run Program
###############################################################################

# Call the _main function after everything has been defined.
_main
